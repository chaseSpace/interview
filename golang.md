# Go 基础篇

本文档不会介绍Golang的基础语法或特性，文中的代码示例均通过验证，但理论方面可能需要考证。

## 语言的优缺点

### 优点

- 是一种现代编程语言，由专家程序员打造
- 语法简单易读，方便多人协作
- 出色的性能：
- 快速编译：即使是大型项目，也只需要十几秒，远远快于Java和Cpp动则按分钟计算的编译时间
- 编译器能够输出直观的警告和错误提示
- 具有稳健的包管理机制
- 具有跨平台特性（通过交叉编译）
- 支持泛型（从1.18版本开始）
- 支持并发编程
- 支持反射
- 支持自动GC，不需要手动处理内存分配和释放问题
- 提供丰富的基础库，便于开发各种应用，如HTTP、JSON等
- 默认使用静态链接，编译成功即可运行
- 丰富的生态：包含常用第三方工具或sdk。如各种数据库、消息队列、缓存等的SDK
- 成名项目：K8s/Docker/Prometheus/Istio/Nsq等

此外，还有强大的社区支持，以及大量使用它的程序员群体。

### 缺点

- 不直接支持面向对象编程，但可以通过结构体模拟
- 错误处理机制过于原始，导致代码中充斥着大量的`if err != nil`

## 内部机制

### 垃圾收集（GC）

垃圾回收就是对程序中不再使用的内存资源进行回收的操作。常见的GC算法有：

- 引用计数：每个对象维护一个引用计数，当被引用对象被创建或被赋值给其他对象时引用计数自动加 +1；如果这个对象被销毁，则计数 -1
  ，当计数为 0 时，回收该对象。
    - 优点：对象可以很快被回收，不会出现内存耗尽或到达阀值才回收。
    - 缺点：不能很好的处理循环引用
- 标记-清除：从根变量开始遍历所有引用的对象，引用的对象标记“被引用”，没有被标记的则进行回收。
    - 优点：解决了引用计数的缺点。
    - 缺点：整个过程需要 STW（stop the world），暂时停止程序运行，这会导致短暂延迟。
- 分代收集：按照对象生命周期长短划分不同的代空间，生命周期长的放入老年代，短的放入新生代，不同代有不同的回收算法和回收频率。
    - 优点：回收性能好
    - 缺点：算法复杂

Go从1.5版本开始使用三色标记-清除法是对标记-清除算法的改进，旨在减少GC导致的延迟。

> [!NOTE]
> 这里所说的对象是指内存中已分配的空间块，而不是代码中的变量。

#### 标记-清除法

此法分为两阶段：标记阶段和清除阶段。

- （stop the world）
- 标记阶段：从根对象（堆或栈变量）开始，通过可达性分析遍历整个对象图，标记所有能够被直接或间接访问到的对象为“活动”状态
- 清除阶段：后清除所有未被标记的对象。部分实现会通过延迟清除来减少产生的延迟。
- （start the world）

此法的缺点是整个阶段执行“stop the world”，这会导致较大延迟。另外，此法没有处理内存碎片，
会导致内存分配效率低。

> [!NOTE]
> 此法又可以叫做双色标记-清除法，即黑色表示活动状态，白色为非活动状态。

#### 三色标记-清除法

<div>
<img src="img/tri-mark-sweep.png" width="500" height="400" alt="">
</div>

此法是对标记-清除法的改进。它引入了**并发标记和清扫**、**三色替换双色**以及**写屏障**技术。

**并发标记和清扫**

又叫增量式标记。相比之前的标记-清除法需要在整个阶段中执行一次完整的STW，此法允许在标记过程中，程序仍然可以执行，
也就是GC线程与用户线程交替执行，逐步完成标记任务。这种方式将原本时间较长的暂停时间切分成多个更小的 GC
时间片。当然，伴随的一个小缺点是总的GC时间变长了。
总的来说，利大于弊。

**三色替换双色**

引入并发标记后，会存在一个问题。在双色标记算法中，一个黑色的对象可能会在标记后指向一个尚未扫描的白色对象，
由于黑色对象这条链已经扫描过就不会再次扫描，最终导致白色对象被遗漏。引入三色标记后，如果黑色对象指向一个白色对象，
则将该白色对象标记为灰色，表示需要再次扫描，这样就实现了GC的暂停和恢复。

三色如下：

- 白色：表示需要GC的对象（不可达）
- 灰色：表示正在进行标记的对象，其引用链还未标记（等会需要标记为黑色）
- 黑色：表示不需要GC的对象（正在被引用）

具体过程如下：

1. 初始时，默认所有对象都是白色（表示尚未被GC线程扫描过）
2. 从根节点开始遍历（非递归），所有根节点直达的对象（如全局变量或栈中的变量）被标记为灰色
    - 从此刻开始， 剩余的那些白色对象将不再被跟踪，最终都会被清除
3. 递归遍历所有灰色对象，将其引用链上的对象标记为灰色
4. 将所有灰色对象标记为黑色
5. 异步清除所有白色对象

可见扫描结束后只剩下白色和黑色两种对象。
此法仍然存在内存碎片的问题，所以很多GC算法仍然会在此法之上添加**内存整理**的算法。

> [!NOTE]
> “扫描”可以称作“标记”，因为扫描结束后，最终只剩下白色和黑色两种对象，而根节点可达对象都会被标记为黑色，
> 不可达对象则本身就是白色无需标记。

**FAQ**

- 灰色对象会被重新标记为白色吗？
    - 不会。因为灰色对象是可达的，它们可能在稍后被引用。
- 扫描完成后，什么对象才是白色的？
    - 那些完全不可达的对象。比如`a="x1";a="x2"`这段代码中`a`被重新赋值后，"x1"就没有用途，完全不可达。而"x2"通过根节点变量直达。
- 清除过程具体是怎样的？
    - 调度器会启动两个协程，一个负责清除与合并空闲页，一个负责向操作系统归还内存。

**直接取消STW会发生什么？**

存在一种情况，在**时刻1**中一个灰色对象与白色对象之间存在引用链，在**时刻2**中灰色与白色断开引用，同时白色被另一个黑色引用。
此时根据前面的标记规则：<u>黑色对象引用链上只有灰色会被标黑</u>，而白色最终会称为弃子（垃圾）。

所以要想在标记阶段取消STW，必须要解决引用链变化导致的漏标问题。而写屏障技术就是为了解决这个问题。

#### 写屏障

<div>
<img src="img/gc_process.png" width="700" height="500" alt="">
</div>

写屏障是一种编程技术，常用于垃圾回收的实现中。在垃圾回收的并发标记阶段，**如果引用链发生变化就会触发写屏障**
（比如变量指向了其他对象或被设置为nil）。

在Go语言的GC算法中，写屏障技术主要分为三种：插入屏障&删除屏障（已废弃）和混合写屏障。

#### Go 1.5 的插入屏障和删除屏障

- 插入屏障：指针修改时，指向的新对象要标灰（无论新对象是灰是白）。
    - 这样可以确保白色对象不会被误清除。
- 删除屏障：指针置空时，修改前指向的对象要标灰（无论该对象是灰是白）。
    - 为灰色说明其引用链还没有完成标记
    - 为白色说明还没有标记到此对象。若不标记为灰色，则此对象将一直是白色，并最终被清除。

引用链变化情况无法就是插入和删除两种，所以只要确保这两种情况下不发生漏标即可。此外，屏障技术都在并发标记过程中针对 **堆空间
**使用，而不会对栈空间使用。写屏障通过一个全局开关（`runtime.writeBarrier.enabled`）启用，启用后，
所有堆空间中针对变量（或成员字段）的写操作（引用链变化）都会触发写屏障（一种Hook机制）。

> [!NOTE]
> 不对栈空间触发的原因是栈的管理通常比堆更简单、更高效，并且程序可能正在运行大量的goroutine，
> 此时在栈上实施屏障机制会增加额外的开销。

> [!NOTE]
> 插入屏障技术由 Dijkstra 提出，删除屏障技术由 Yuasa 提出。

##### 上述屏障机制的缺点

由于屏障机制不对**栈空间**中的对象使用，
所以当第一轮三色标记阶段完成后，在垃圾回收前还会再针对栈空间进行**重新扫描**（并发进行），并且期间需要触发STW。

此外，删除屏障是一种保守的做法，即保护了那些被删除稍后又被其他对象引用的对象，但这种做法同时也保护了实际上已经没有任何引用的对象。
这就导致了回收精度低。

示例：

```cgo
# 创建引用关系：c->b->a
a := 1
b := a
c := b

# 删除引用关系: c->1  b->a
# 此刻b和a已没有任何用途
c = 1
print(c)
```

#### Go 1.8 的混合写屏障

1.8版本更新了标记算法，并引入了混合写屏障技术，但仍然只对堆空间使用。
混合写屏障结合了删除屏障和插入屏障两种写屏障技术，避免了对栈的重扫需求。

具体步骤如下:

- 默认全白色
- 先设置所有栈上可达对象为黑色（不可达对象仍然是白色）
- 栈上的新对象也直接设为黑色（默认可能被引用）
- 堆中新增/删除对象标记为灰色，继续跟踪其可达情况（混合写屏障）

这个算法不会重新扫描栈空间，因此减少了STW的时间，但栈空间被删除的对象仍然会存活到下一轮GC。

### unsafe 包

### defer 关键字

### strace 和 dtrace 工具

## 基本数据类型

### 数组的缺点

### 切片的优点

## 字符串

### rune

### unicode

### strings

## Go 包

### syscall 包

### go/scanner、go/token 和 go/parser 包

## 反射和接口

### 反射的缺点

### reflectwalk库

### 使用Delve调试

## 并发编程

### 进程、线程和协程

#### Go调度器

### select 关键字

### 共享内存和共享变量

### 竞态条件

### 与Rust并发模型比较

### 与Erlang并发模型比较