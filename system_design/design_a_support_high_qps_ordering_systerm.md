# 如何设计一个支持高并发的下单流程

## 设计思路

高并发下单是电商系统中最具挑战性的场景之一。当大量用户同时抢购热门商品时，系统需要在极短时间内处理海量请求，同时保证数据的一致性和准确性。如果设计不当，
轻则导致服务响应缓慢、用户体验差，重则引发系统崩溃、库存超卖等严重问题。

### 核心思路：分层处理，逐步解耦

面对高并发场景，我们采用**分层处理、逐步解耦**的设计思路，将下单流程拆分为多个阶段，每个阶段专注于解决特定的问题：

1. **流量接入层**：快速响应，拒绝无效请求
2. **业务处理层**：异步化处理，提升吞吐量
3. **数据持久层**：保证强一致性，防止数据错误
4. **最终一致性保障**：兜底机制，确保数据最终正确

### 整体流程设计

```
用户下单 → 前端防抖 → 缓存层预扣减 → MQ异步处理 → DB事务扣库存 → 结果写入 → 前端轮询状态
```

### 设计原则

- **用户体验优先**：快速响应用户请求，避免长时间等待
- **系统稳定性**：通过降级、限流等手段保护系统不被击垮
- **数据一致性**：在性能和一致性之间找到平衡点
- **可扩展性**：各层解耦，便于独立扩容和优化

### 关键技术点

接下来的章节将详细介绍每个阶段的具体实现方案，包括：

- 前端使用防抖机制过滤大部分无效请求
- 使用缓存层抗住第一波流量
- 使用MQ异步化下单流程提升吞吐量
- 使用DB事务保证库存一致性
- 通过MQ或定时任务保证最终一致性
- 设计前端轮询机制优化用户体验

## 前端使用防抖机制

在用户下单时，前端需要使用防抖机制，防止用户快速点击下单按钮，导致下单请求被重复发送。

> 这一步不能忽略，在超高流量下，这一步骤就能减少60%以上的无效请求。

## 使用缓存层抗住第一波流量

### 为什么需要缓存层

在高并发抢购场景下，如果所有请求都直接打到数据库，数据库会瞬间被压垮。数据库的并发处理能力有限（通常每秒只能处理几千次请求），
而Redis等缓存组件可以轻松支撑每秒数万甚至数十万次的请求。

缓存层在这里的作用是：**作为第一道防线，快速拦截和过滤大部分请求**。

### 缓存层的主要功能

#### 1. 库存预热

在抢购开始前，将商品库存信息预热到Redis中。在实现上，一般分为几个步骤：

**1️⃣Redis Key设计**

```
stock:{sku_id} = 1000        # 当前可卖库存
stock:init:{sku_id} = 1000   # 初始库存（校验 / 修复用）
stock:sold:{sku_id} = 0      # 已售数量（可选）

SET activity:preheated:{sku_id} = 1 # 预热标记，控制活动是否启动（根据需要）
```

⚠️ 不要只放一个 key，后期无法对账和修复。

**2️⃣预热执行逻辑（单 SKU）**

大致步骤：DB事务内计算可卖库存、Redis事务写入库存字段。⚠️ 预热一定要 幂等，支持重复执行。

> 可卖库存 = 总库存 - 已锁 - 已售。

**3️⃣ 批量预热（活动常态）**

- 定时任务
- 管理后台点击
- 发布活动时自动触发

#### 2. 库存预扣减

用户下单时，先在Redis中扣减库存，使用Lua脚本确保原子性。

#### 3. 快速拒绝无效请求

当Redis中库存不足时，直接返回"库存不足"，不再继续后续流程。这可以大幅减少无效请求对后端的压力。

### 完整流程

```
用户下单请求
    ↓
检查Redis缓存中是否有库存
    ↓
库存充足 → 扣减Redis库存 → 发送MQ消息 → 返回"下单成功"
    ↓
库存不足 → 直接返回"库存不足"
```

### 关键技术点

#### 1. 使用Lua脚本保证原子性

库存扣减必须是原子操作，防止并发请求导致超卖。使用Lua脚本可以保证"检查库存"和"扣减库存"这两个操作的原子性。

#### 2. 缓存更新与过期

- 缓存更新：极少数情况下，若发现缓存有误或需要手动更新时（增减库存），使用API主动更新缓存。
- 缓存过期：为缓存设置一个稍大于活动持续时间的过期时间，实现缓存释放（活动期间不过期）。

#### 3. 限流保护

即使有缓存层，也需要在下单接口层面增加限流措施，如令牌桶、漏桶算法等，防止恶意请求击穿缓存层。

> 触发限流机制的请求直接返回"请求处理中"或"操作太快，稍后再试"。

### 可能的问题与解决方案

#### 问题1：缓存与数据库数据不一致

**原因**：Redis扣减成功后，后续流程失败，导致Redis库存已扣减但数据库库存未扣减。

**解决方案**：

- 使用MQ异步处理，确保最终一致性（下一节详细说明）
- 定时任务对账，发现不一致时进行修复

### 总结

缓存层是高并发下单系统的第一道防线，通过在Redis中预扣减库存，可以：

1. **大幅提升系统吞吐量**：从每秒几千次提升到数万次
2. **保护后端数据库**：过滤掉大部分无效请求
3. **快速响应用户**：减少用户等待时间

但需要注意的是，缓存层只能保证"最终一致性"，不能保证强一致性。因此需要配合MQ和定时任务来保证数据最终一致（后续章节会详细说明）。

## 使用MQ异步化下单流程

## 使用DB事务保证库存一致性

## 使用MQ或定时任务保证最终一致性

## 前端轮询状态