# 系统设计基础

## 系统设计的三大目标

- 高性能（High Performance）
- 高可用（High Availability）
- 高扩展（High Scalability）

回答问题时，脑子里要先有一张“架构地图”。

### 高性能架构设计：核心目标是“快”

性能瓶颈的本质：CPU/内存/IO（磁盘 / 网络）。
引入的任何优化手段，本质都是在减少慢路径或提高资源利用率。

#### 解决CPU瓶颈

CPU瓶颈的本质是：算不过来。原因如下方面：

- 计算密集
    - 复杂业务逻辑
    - 大量加解密、压缩、正则、序列化/反序列化
- 上下文切换过多
    - 线程/协程数量失控
    - 锁竞争严重
- 单核瓶颈
    - 单线程模型
    - 某些热点逻辑无法并行

**解决思路（从软件到架构）**

1. 算法实现层
    - 采用更优化的算法降低时间复杂度
    - 避免重复计算（缓存中间结果）
    - 减少序列化、反射、动态解析
2. 并行化
    - 多线程/多协程
    - 分片并行：通过将数据或任务拆分成多个相互独立的分片并行处理，从而提升整体吞吐和 CPU 利用率，例如Map-Reduce。
    - CPU 绑定：CPU 绑定通过减少线程在不同核心之间迁移，提高 CPU cache 命中率，降低调度开销，从而提升吞吐和稳定性。
    - 线程池限流：限制并发执行的线程数，避免过度上下文切换和 CPU 争抢，使系统在高负载下保持可控和稳定。
3. 架构层
    - 水平扩展（Scale Out）：通过多节点部署无状态服务分散单节点CPU压力
    - 异步化：非关键逻辑异步处理（MQ / 任务队列）

#### 解决内存瓶颈

内存瓶颈的本质是：放不下 / 管不过来。有如下原因：

- 内存泄露
- GC 压力大
- 缓存命中率低
- 数据量过大

**解决思路**

1. 数据结构与对象管理

- 减少对象创建（对象池、复用）
- 使用紧凑数据结构（数组 > Map > 对象）
- 控制缓存大小（LRU / LFU）

2. 缓存设计

- 本地缓存（进程内）
- 分布式缓存（Redis）
- 热点数据缓存，冷数据回源

3. 架构层

- 读写分离（适合读多写少）
- 数据分片：单机内存放不下 → 水平拆分

#### 解决磁盘 I/O 瓶颈

磁盘 I/O 瓶颈的本质是：读写太慢。原因如下方面：

- 随机 I/O 多
- 磁盘访问频繁
- 大量同步写
- 索引设计不合理

**解决思路**

1. 减少磁盘访问
    - 缓存：Page Cache、Redis / 本地缓存。
    - 数据库设计合理索引，避免全表扫描

2. 顺序化 & 批量化
    - 顺序写（WAL / Append Log）
    - 批量写入（Batch）
    - 合并小 I/O

3. 架构层
    - SSD / NVMe
    - 数据冷热分离
    - 日志与数据分盘

#### 解决网络 I/O 瓶颈

网络 I/O 瓶颈 的本质：传得太慢 / 太多。原因如下方面：

- 底层I/O 模型不是最优：采用epoll+主从Reactor网络模型
- RPC 次数多
- 数据包大
- 跨机房调用
- 阻塞 IO

**解决思路**

1. 减少网络交互
    - 减少请求链路层级
    - 服务内聚，避免过度拆分

2. 提升网络效率
    - 压缩（gzip / snappy）
    - 二进制协议（Protobuf / messagepack）
    - 连接复用（KeepAlive / HTTP2）

3. 架构层
    - 就近访问（同机房 / 同可用区）
    - CDN（静态资源）
    - 异步调用

#### 小结

- CPU：减少计算 + 并行
- 内存：少对象 + 高命中缓存
- 磁盘：少 IO + 顺序化
- 网络：少交互 + 少数据

### 高可用架构设计：核心目标是“不挂”

高可用的目标不是“永不出错”，而是“出错了系统还能对外提供可接受的服务”。

#### 理论基础

1. CAP 定理

- C 一致性
- A 可用性
- P 分区容错性（分布式系统必须要）

提示：网络一定会出问题，实际是在 C 和 A 之间取舍。

2. BASE 定理

- Basically Available（基本可用）
- Soft State（软状态）
- Eventually Consistent（最终一致）

#### 核心原则

- 冗余：任何单点都会失败
- 隔离：故障不能扩散
- 快速失败：不要拖死系统
- 可恢复：自动恢复优先于人工