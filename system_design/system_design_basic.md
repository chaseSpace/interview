# 系统设计基础

## 系统设计的三大目标

- 高性能（High Performance）
- 高可用（High Availability）
- 高可扩展（High Scalability）

回答问题时，脑子里要先有一张“架构地图”。

### 高性能架构设计：核心目标是“快”

性能瓶颈的本质：CPU/内存/IO（磁盘 / 网络）。
引入的任何优化手段，本质都是在减少慢路径或提高资源利用率。

### 高可用架构设计：核心目标是“不挂”

高可用的目标不是“永不出错”，而是“出错了系统还能对外提供可接受的服务”。

#### 理论基础

1. CAP 定理

- C 一致性
- A 可用性
- P 分区容错性（分布式系统必须要）

提示：网络一定会出问题，实际是在 C 和 A 之间取舍。

2. BASE 定理

- Basically Available（基本可用）
    - 允许系统在出现故障时，损失部分可用性，但仍能对外提供基本服务。
- Soft State（软状态）
    - 系统中的数据状态可以在不同节点间存在中间状态。
- Eventually Consistent（最终一致）
    - 系统在经过一段时间后，最终能够达到一致状态。

**BASE 与 CAP 定理的关系**

- BASE 定理提供了一种实际的折衷方案，通过接受最终一致性来换取系统高可用性
- BASE 是对 CAP 中 AP 系统（可用性优先）的具体实现方式。

#### 具体技术实现方案

##### 1. 服务冗余（消除单点）

- 多实例部署：同一个服务部署多个实例，避免单点故障
- 负载均衡：通过负载均衡器（Nginx、HAProxy、SLB）将流量分发到多个实例
- 健康检查：定期检查服务实例健康状态，自动剔除异常实例
- 跨机房/跨区域部署：在多个机房或区域部署服务，应对机房级故障
- 多活架构：多个机房同时提供服务，实现异地多活

##### 2. 流量控制（保护系统）

- 限流：限制系统的请求处理速率，防止流量过载
    - 令牌桶算法：恒定速率放入令牌，请求获取令牌才能通过
    - 漏桶算法：恒定速率处理请求，多余请求被丢弃
    - 固定窗口：在固定时间窗口内限制请求数
    - 滑动窗口：更平滑的限流方式，避免临界问题
    - 分布式限流：基于 Redis 实现跨实例的限流
- 熔断：当服务出现故障时，快速失败，避免级联雪崩
    - 熔断器状态：关闭（正常）、打开（熔断）、半开（尝试恢复）
    - 熔断策略：错误率阈值、响应时间阈值、异常数阈值
    - 常见实现：Hystrix、Resilience4j、Sentinel
- 降级：在系统负载过高或服务异常时，牺牲部分功能保证核心功能可用
    - 功能降级：关闭非核心功能（如评论、推荐）
    - 读降级：返回缓存数据或默认值
    - 写降级：异步写入或降级存储

##### 3. 故障隔离（防止扩散）

- 资源隔离：不同服务使用独立的线程池、连接池、内存等资源
- 进程隔离：不同服务部署在不同进程或容器中
- 机房隔离：不同机房的服务独立部署，避免跨机房故障扩散
- 租户隔离：多租户系统按租户隔离资源
- 数据库隔离：核心业务与次要业务使用不同的数据库实例

##### 4. 超时与重试（提高容错）

- 超时控制：为所有远程调用设置合理的超时时间
    - 连接超时：建立连接的最大等待时间
    - 读取超时：等待响应的最大时间
    - 超时时间设置：根据业务容忍度和服务 SLA 确定
- 重试机制：在失败时自动重试，提高成功率
    - 重试策略：固定间隔、指数退避、随机退避
    - 重试次数：限制最大重试次数，避免无限重试
    - 幂等性：确保重试不会产生副作用
    - 重试触发条件：网络异常、超时、特定错误码

##### 5. 数据备份与恢复（保障数据）

- 数据库主从复制：主库写入，从库读取，实现读写分离
- 数据库集群：MySQL MGR、PostgreSQL Patroni、MongoDB Replica Set
- 定期备份：全量备份 + 增量备份
- 备份验证：定期验证备份的可用性
- 跨机房备份：备份数据存储到异地机房
- 快照备份：使用云服务的快照功能快速备份
- 数据恢复演练：定期演练数据恢复流程

##### 6. 缓存高可用（提升可用性）

- Redis 主从复制：主节点写入，从节点读取
- Redis Sentinel：自动故障检测和故障转移
- Redis Cluster：分布式集群，自动分片和故障转移
- 多级缓存：本地缓存 + 分布式缓存，降低对单点的依赖
- 缓存预热：系统启动时加载热点数据
- 缓存降级：缓存不可用时直接访问数据库

##### 7. 消息队列高可用（异步解耦）

- MQ 集群部署：Kafka、RabbitMQ、RocketMQ 都支持集群模式
- 消息持久化：消息持久化到磁盘，避免丢失
- 消息确认机制：确保消息被正确处理
- 死信队列：处理无法正常消费的消息
- 消息重试：消费失败时自动重试
- 消息幂等：确保重复消费不会产生副作用

##### 8. 监控与告警（及时发现问题）

- 监控指标：
    - 系统指标：CPU、内存、磁盘、网络
    - 应用指标：QPS、响应时间、错误率、吞吐量
    - 业务指标：订单量、注册量、支付成功率
- 监控工具：Prometheus + Grafana、Zabbix、ELK
- 日志收集：集中收集和分析日志（ELK Stack）
- 链路追踪：分布式追踪系统（Jaeger、Zipkin、SkyWalking）
- 告警策略：多级告警、告警聚合、告警收敛
- 告警渠道：邮件、短信、钉钉、Slack

##### 9. 灰度发布（降低发布风险）

- 蓝绿部署：同时维护两套环境，切换流量
- 金丝雀发布：先发布到少量实例，观察无问题后全量发布
- A/B 测试：同时运行多个版本，根据用户行为选择最优版本
- 滚动发布：逐个实例更新，保持服务始终可用
- 特性开关：通过配置控制功能开关，快速回滚

##### 10. 灾备演练（验证可用性）

- 混沌工程：主动注入故障，验证系统容错能力
- 故障演练：模拟服务宕机、网络故障、磁盘故障等场景
- 容灾演练：定期进行机房切换演练
- 应急预案：制定详细的故障处理流程
- 故障复盘：故障后进行复盘，总结经验教训

##### 11. 常见高可用指标

- 可用性：99.9%（8.76 小时/年）、99.99%（52.56 分钟/年）、99.999%（5.26 分钟/年）
- MTBF（Mean Time Between Failures）：平均故障间隔时间
- MTTR（Mean Time To Repair）：平均修复时间
- RPO（Recovery Point Objective）：恢复点目标，数据可容忍的最大丢失量
- RTO（Recovery Time Objective）：恢复时间目标，服务可容忍的最大停机时间

#### 小结

高可用架构设计是一个系统工程，需要从多个层面考虑：

1. **架构层面**：消除单点、多级冗余、异地多活
2. **技术层面**：限流、熔断、降级、超时、重试
3. **数据层面**：备份、复制、分片、缓存
4. **运维层面**：监控、告警、灰度、演练
5. **流程层面**：应急预案、故障复盘、持续改进

**关键原则**：

- 任何单点都会失败，必须消除单点
- 故障不可避免，但要限制影响范围
- 自动化优于人工操作
- 演练验证，不做纸上谈兵

### 高可扩展架构设计：核心目标是"能长大"

高可扩展的目标是系统能够通过增加资源（硬件或软件）来应对不断增长的负载和数据量，而无需对架构进行大规模重构。

#### 理论基础

1. 可扩展性分类

- 垂直扩展（Scale Up）：升级单机硬件配置（CPU、内存、磁盘）
- 水平扩展（Scale Out）：增加机器数量，通过分布式架构扩展

2. 扩展性原则

- 无状态服务：应用层服务无状态，便于水平扩展
- 数据分片：通过分片策略将数据分散到多个节点
- 缓存分层：多级缓存降低对数据库的压力
- 异步解耦：通过消息队列实现异步处理，削峰填谷
- 弹性伸缩：根据负载自动调整资源

#### 垂直扩展与水平扩展

**垂直扩展（Scale Up）**

升级单机硬件配置（CPU、内存、磁盘）。

- 优点
    - 实现简单，无需修改代码
    - 数据一致性容易保证
    - 网络开销小
- 缺点
    - 硬件成本高，单机性能有上限
    - 存在单点故障风险
    - 扩展能力有限
- 适用场景
    - 初期业务量不大
    - 数据量较小，单机能承载
    - 对数据一致性要求极高

**水平扩展（Scale Out）**

增加实例或机器数量，通过分布式架构扩展。

- 优点
    - 扩展能力强，理论上无上限
    - 成本相对可控，使用普通服务器
    - 高可用性好，避免单点故障
- 缺点
    - 架构复杂，需要处理分布式问题
    - 数据一致性难以保证
    - 运维成本高
- 适用场景
    - 业务量大，持续增长
    - 数据量大，需要分片
    - 对可用性要求高

#### 应用层扩展

**无状态服务设计**

- Session 管理
    - 使用 Redis 存储 Session
    - 使用 JWT（JSON Web Token）无状态认证
    - Session Sticky（会话粘滞）作为临时方案
- 文件存储
    - 使用对象存储（OSS、S3）
    - 使用分布式文件系统（HDFS、GlusterFS）
- 本地缓存
    - 避免使用本地缓存，或实现缓存一致性机制

**负载均衡**

- 四层负载均衡（L4）
    - 基于 IP 和端口进行转发
    - 性能高，但只能基于 IP 分发
    - 常见实现：LVS、HAProxy
- 七层负载均衡（L7）
    - 基于 HTTP 协议内容进行转发
    - 可以根据 URL、Cookie 等进行智能路由
    - 常见实现：Nginx、Envoy、Traefik、Kong
- 负载均衡策略
    - 随机（Random）
    - 加权随机（Weighted Random）
    - 轮询（Round Robin）
    - 加权轮询（Weighted Round Robin）
    - 最少连接（Least Connections）
    - 一致性哈希（Consistent Hash）

**弹性伸缩**

- 手动伸缩
    - 根据监控指标手动调整实例数量
- 自动伸缩
    - 基于时间：定时扩容/缩容
    - 基于指标：CPU、内存、QPS 等
    - 基于预测：使用机器学习预测负载
- 容器化与编排
    - Docker 容器化部署
    - Kubernetes 自动扩缩容（HPA）
    - Serverless 自动伸缩

#### 数据层扩展

**数据库读写分离**

- 主从复制
    - 主库负责写操作
    - 从库负责读操作
    - 通过复制机制保持数据同步
- 读写分离中间件
    - MyCat、ShardingSphere
    - ProxySQL、MySQL Router
- 注意事项
    - 主从延迟问题
    - 路由策略设计
    - 故障切换机制

**数据库分库分表**

- 垂直分库
    - 按业务模块拆分
    - 不同业务使用不同数据库
    - 降低单库压力
- 垂直分表
    - 按字段拆分
    - 热点字段与冷字段分离
    - 减少单表数据量
- 水平分库
    - 按数据量拆分
    - 将数据分散到多个数据库
    - 提升整体存储和查询能力
- 水平分表
    - 按数据量拆分
    - 将数据分散到多个表
    - 提升单表查询性能
- 分片策略
    - 范围分片（Range）：按 ID 范围分片
    - 哈希分片（Hash）：按哈希值分片
    - 一致性哈希（Consistent Hash）：解决节点增减问题
    - 地理位置（Geo）：按地理位置分片
- 分片中间件
    - ShardingSphere
    - MyCat
    - Vitess
- 注意事项
    - 跨分片查询问题
    - 分布式事务问题
    - 分片键选择
    - 数据迁移问题

**数据库集群**

- MySQL 集群
    - MySQL Group Replication（MGR）
    - InnoDB Cluster
- PostgreSQL 集群
    - Patroni + etcd
    - Citus（分布式 SQL）
- NoSQL 集群
    - MongoDB Replica Set
    - Cassandra（天然分布式）
    - HBase（分布式列式存储）

#### 缓存层扩展

**分布式缓存**

- Redis 集群
    - Redis Cluster：官方集群方案
    - Codis：代理方案
    - Twemproxy：代理方案
- 缓存分片
    - 一致性哈希
    - 虚拟节点
    - 节点动态增减
- 缓存策略
    - Cache Aside：旁路缓存（常用）
      - 读取：先查询缓存，缓存不存在则从数据库中读取，读取值写入缓存。
      - 写入：先写入数据库，写入成功后清除缓存。
      - 缺点：并发导致脏缓存
      - 优点：实现简单，适合读多写少的场景
    - Read Through：读穿透
      - 特点：APP只会与缓存组件交互，缓存组件再和数据库交互。
      - 读取：缓存层来实现从数据库载入数据的步骤
      - 写入：不涉及。
      - 优点：APP逻辑简单
      - 缺点：依赖缓存层的可靠性
    - Write Through：写穿透
      - 特点：缓存层管理写入，写入时同时更新缓存和数据库
      - 读取：不涉及。
      - 写入：缓存层在写入时，若缓存命中，则更新缓存和数据库；否则只更新数据库。
    - Write Back：写回策略
      - 特点：先写缓存，批量异步写数据库/文件。类似于操作系统的页缓存机制。
      - 缺点：系统故障可能导致数据丢失。
      - 优点：大幅提升写入性能，适合对写入性能要求极高的场景，允许短暂数据不一致的业务。

**多级缓存**

- 本地缓存
    - Guava Cache
    - Caffeine
    - Ehcache
- 分布式缓存
    - Redis
    - Memcached
- 缓存架构
    - L1：本地缓存（进程内）
    - L2：分布式缓存（Redis）
    - L3：CDN 缓存
- 缓存一致性
    - 缓存失效策略
    - 消息通知机制
    - 版本号机制

#### 消息队列扩展

**消息队列集群**

- Kafka 集群
    - Broker 集群
    - Topic 分区
    - 副本机制
- RabbitMQ 集群
    - 镜像队列
    - Federation 插件
    - Shovel 插件
- RocketMQ 集群
    - Broker 集群
    - NameServer 集群
    - 多副本机制

**消息分片**

- Topic 分区
    - 按分区并行消费
    - 提升消费吞吐量
- 消息路由
    - 按键路由（Key-based Routing）
    - 轮询路由（Round Robin）
    - 自定义路由策略

#### 微服务架构

**服务拆分**

- 拆分原则
    - 单一职责
    - 高内聚低耦合
    - 业务边界清晰
- 拆分维度
    - 按业务领域拆分
    - 按功能模块拆分
    - 按数据拆分
- 拆分策略
    - 绞杀者模式（Strangler Pattern）
    - 领域驱动设计（DDD）

**服务治理**

- 服务注册与发现
    - Etcd
    - Consul
    - Eureka
    - Nacos
    - Zookeeper
- 服务网关
    - Nginx
    - Envoy
    - Kong
    - Spring Cloud Gateway
    - Traefik
    - Istio Gateway
- 配置中心
    - Apollo
    - Nacos
    - Consul
    - Etcd
- 服务熔断与降级
    - Hystrix
    - Resilience4j
    - Sentinel

**服务扩展**

- 独立扩展
    - 不同服务独立扩展
    - 根据业务需求调整资源
- 弹性伸缩
    - 根据负载自动扩展
    - 支持快速扩缩容
- 蓝绿部署
    - 零停机部署
    - 快速回滚

#### 扩展性设计最佳实践

1. **架构设计原则**

- 无状态优先
- 分层设计
- 异步解耦
- 最终一致性
- 弹性设计

2. **扩展策略**

- 先垂直后水平
- 先读写分离后分库分表
- 先缓存后数据库
- 先同步后异步

3. **监控与调优**

- 监控系统瓶颈
- 预测容量需求
- 提前规划扩展
- 持续优化架构

#### 扩展性设计小结

高扩展架构设计是一个持续演进的过程，需要从多个层面考虑：

1. **应用层**：无状态设计、负载均衡、弹性伸缩
2. **数据层**：读写分离、分库分表、数据库集群
3. **缓存层**：分布式缓存、多级缓存、缓存一致性
4. **消息层**：消息队列集群、消息分片、异步解耦
5. **架构层**：微服务架构、服务治理、独立扩展

**关键原则**：

- 无状态是水平扩展的基础
- 分片是解决数据规模的核心
- 缓存是提升性能的有效手段
- 异步是削峰填谷的重要方式
- 监控是容量规划的依据