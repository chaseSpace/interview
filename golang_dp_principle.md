# 设计模式的六大原则

设计模式被设计出来的时候，是遵循六大原则的，它们的英译首字母组合起来是Solid，所以也叫做SOLID（中译：稳定的）原则。
它们分别是：

1. 单一职责原则(Single Responsibility Principle)
2. 开闭原则(Open Closed Principle)
3. 里氏替换原则(Liskov Substitution Principle)
4. 迪米特法则(Law of Demeter)
5. 接口隔离原则(Interface Segregation Principle)
6. 依赖倒置原则(Dependence Inversion Principle)

本篇也是[Go 设计模式篇](golang_designpattern.md)的前篇。

## 0. 笔者注

虽然叫做设计原则，但在实践中也要因地制宜，而不是教条式地照搬。在有些情况下，如果要完全遵循某项设计原则，可能会导致代码量剧增，
并且没有足够的时间来实施；还有一类情况，比如项目需要快速上线，那么完全可以简化设计，然后在后续迭代中逐渐完善。
但任何时候都要避免编写一些封闭式的逻辑（不要把优化方向堵死），因为这样会导致后期优化和维护困难，甚至导致重构。

## 1. 单一职责原则

一个类应该只有一个职责。这样做的好处是提高类的可维护性和复用性。如果一个类承担过多职责，则应该拆分。

> 在Go语言中一个类应理解为一个构造函数，或者一个由多个方法组成的接口。

## 2. 开闭原则

一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。这意味着在不修改现有代码的情况下，可以通过添加新的代码来扩展系统的功能。

## 3. 里氏替换原则

所有引用基类的地方必须能够透明地使用其子类的对象。换句话说，子类必须能够**等价替换**基类而不影响程序的正确性。
具体来说，我们在定义接口类和子类时需要遵循以下原则：

- 子类需要实现基类的抽象方法，但不能重写基类中的非抽象方法（Java中的类可以同时包含抽象方法和非抽象方法）
  - 例如基类中已实现了`func abc()`方法，子类只允许继承这个方法，而不可以重写它。因为重写后就无法做到子类同等替换父类了。
- 子类中可以增加自己特有的方法
  - 例如基类中已实现了`func abc()`方法，子类可以增加自己的`func xyz()`方法。这不影响父类。
- 子类重载父类时，子类方法的形参必须比父类方法形参更宽松（仅适用于Java）
  - 如果不这样，在调用与父类的同名方法时，会优先调用子类而不是父类。

## 4. 迪米特法则

一个对象应该对其他对象有最少的了解。换句话说，一个对象应该只与其密切的朋友交流，而不与陌生对象交流。

如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。

**举例**：客户通过中介了解多个楼盘；用户通过网关访问多个后台服务。

> 许多设计模式都遵循迪米特法则，如代理模式、外观模式、桥接模式、中介者模式。

## 5. 接口隔离原则

每个接口中不存在子类用不到却必须实现的方法，如果不然，就要将接口拆分。接口隔离原则是为了约束接口、降低类对接口的依赖性。

**举例**：一个人可以做很多事，比如吃饭睡觉打豆豆（三个方法）。此时，如果站在人的角度，是否还可以增加一个唱歌的方法呢？
这得从两方面来看，如果是一个歌手，那么可以添加这个方法，同时满足单一职责和接口隔离原则；但如果在人的基础上划分角色，即它是一个不喜欢唱歌的人，
那么就不应该添加这个方法，因为这样会违反接口隔离原则，但仍可能满足单一职责原则。

## 6. 依赖倒置原则

- 高层模块不应该依赖于低层模块，它们都应该依赖于抽象。
- 抽象不应该依赖于具体实现，具体实现应该依赖于抽象。

这是一种面向接口编程的思想，它要求你先设计抽象接口，然后再实现具体类。

**举例**：当你要设计一个发送短信的模块时，首先要考虑的是设计一个发送短信的抽象接口（比如包含登录短信、注册短信、提款短信的方法），
而不是考虑使用哪个运营商的服务（这并不影响业务层调用）。


