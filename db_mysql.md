# MySQL 相关

本文内容部分摘自网络。

## 什么是关系型数据库

一种建立在关系模型的基础上的数据库。关系模型表明了数据库中所存储的数据之间的联系（一对一、一对多、多对多）。
大部分关系型数据库都使用 SQL 来操作数据库中的数据。并且，大部分关系型数据库都支持事务的四大特性(ACID)。

### 常见的关系型数据库

MySQL、PostgreSQL、Oracle、SQL Server、SQLite（微信本地的聊天记录的存储就是用的 SQLite）。

### 数据库三范式

数据库设计中的三范式（3NF，Third Normal Form）是关系数据库中的一种规范化方法，用于消除数据冗余和提高数据一致性。

- 第一范式 (1NF)：确保表中每列的原子性，也就是不可拆分。
- 第二范式 (2NF)：确保数据库表中的每一列都和主键相关。对于联合主键，也必须与联合主键的全部字段相关。
- 第三范式 (3NF)：确保数据表中的每一列数据都和主键直接相关，而不能间接相关。
    - 换句话说，非主键字段之间不能直接相关，而都是通过主键关联。

## 字段类型相关

MySQL 字段类型可以简单分为三大类：

- 数值类型：整型（TINYINT、SMALLINT、MEDIUMINT、INT 和 BIGINT）浮点型（FLOAT 和 DOUBLE）、定点型（DECIMAL）
- 字符串类型：CHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT、TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB 等，最常用的是 CHAR 和
  VARCHAR。
- 日期时间类型：YEAR、TIME、DATE、DATETIME 和 TIMESTAMP 等。

### DECIMAL 和 FLOAT/DOUBLE 的区别是什么

DECIMAL 是定点数，FLOAT/DOUBLE 是浮点数。DECIMAL 可以存储精确的小数值，FLOAT/DOUBLE 只能存储近似的小数值。

### DATETIME 和 TIMESTAMP 的区别是什么

DATETIME 类型没有时区信息，TIMESTAMP 和时区有关。

TIMESTAMP 只需要使用 4 个字节的存储空间，但是 DATETIME 需要耗费 8 个字节的存储空间。但是，这样造成了一个问题，Timestamp
表示的时间范围更小。

- DATETIME：`1000-01-01 00:00:00` ~ `9999-12-31 23:59:59`
- Timestamp：`1970-01-01 00:00:01` ~ `2037-12-31 23:59:59`

### 为什么不建议使用 NULL 作为列默认值

- NULL 与空字符串不同，NULL 需要更多的存储空间。
- 查询 NULL 值需要使用专门的 SQL 语句，比如 `IS NULL`和`IS NOT NULL`，而查询空字符串只需要使用 `=` 或者 `<>` 即可。
- NULL 会影响聚合函数的查询结果，例如，SUM、AVG、MIN、MAX 等聚合函数会忽略 NULL 值。
    - COUNT(*) 会包含 NULL 值所在的行，但 COUNT(col) 不会。
- 查询不便：在查询中使用`NOT IN`或`!=`等反向条件时，查询结果不会包含 NULL 值所在的行，需要加上`ISNULL(col)`。

注意：DISTINCT 会将多个 NULL 值算作一个 NULL。

> 对于不需要做聚合的字段，可以允许 NULL 值。

## 存储引擎

### 有哪些存储引擎

Innodb 和 MyISAM。使用`SHOW ENGINES`查看支持的引擎列表。

### InnoDB 和 MyISAM 对比

- **锁支持**：MyISAM 是表级锁，InnoDB 支持表级锁和行级锁。
- **事务支持**：只有 InnoDB 支持事务。
- **外键支持**：只有 InnoDB 支持外键，但一般不用。
- **崩溃恢复**：只有 InnoDB 支持。数据库在异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态。这个恢复的过程依赖于
  redo log。
- **MVCC 支持**：只有 InnoDB 支持。这是个废话，因为支持事务才支持 MVCC。多版本并发控制，是一种用于实现数据库事务并发控制的技术，可以减少加锁操作，提高性能。
- **索引实现**：都使用 B+Tree 作为索引结构，但实现方式不同。Innodb 实现为聚簇索引，即主键索引和数据存储在一起；MyISAM
  实现为非聚簇索引，即主键索引和数据分开存储。
    - 聚簇索引的叶子节点存储了数据，非聚簇索引的叶子节点存储了数据指针。二级索引的实现没有差别。
- **设置主键**：Innodb 一定拥有一个主键，MyISAM 可以没有主键。
- **性能差别**：InnoDB 的性能比 MyISAM 更强大。

## MySQL 架构分层

MySQL 的架构设计分为多个层次，每个层次负责不同的功能和任务。

- 客户端层：负责与 MySQL 服务器进行通信，主要功能是处理客户端连接。
- 服务层：由多个组件组成。
    - 连接器：管理客户端的连接和用户身份认证和鉴权。
    - 缓存层：尝试查询缓存，如果命中缓存，则直接返回结果，否则再查询数据库。当发生写操作时，缓存会失效。
        - 由于频繁变更的数据表，命中率很低，反而导致读写速度，MySQL 8.0 移除缓存层（需验证！）。
    - 分析器：负责解析 SQL 语句，检查语法错误，并将其分解成解析树。
    - 优化器：对解析树进行优化，生成一个或多个执行计划，选择最有效的查询执行计划。
    - 执行器：调用存储引擎接口，真正的执行 SQL 查询。
- 存储引擎层：可插拔式实现，负责数据的存取，提供统一抽象接口与服务层进行交互。
- 文件系统层：严格来说不属于 MySQL 内部层，但为了方便理解，将它放在这里。
    - 负责管理数据的物理存储，包括表数据、索引、各种日志文件等。
        - 表文件：使用单文件或每表一个文件的形式保存表数据。包含用户表、系统表、临时表等。
        - 索引文件：包含索引数据。
        - 日志文件：分别有 redo-log、undo-log、binlog，以及慢查询、通用查询和错误日志文件。
        - 配置文件：`my.cnf`文件。

## 索引

索引是一种用于快速查询和检索数据的数据结构，本质上是一种经过排序的数据结构。

索引底层数据结构存在很多种类型，常见的索引结构有: B 树， B+树 和 Hash、红黑树。在 MySQL 中，无论是 Innodb 还是 MyIsam，都使用了
B+树作为索引结构。

### 优缺点

优点：

- 显著提高查询速度。
- 加速排序和分组操作。
- 强制数据唯一性，确保数据完整性。

缺点：

- 占用额外的存储空间。
- 插入、更新和删除操作可能变慢，因为索引也需要维护。
- 过多的索引可能导致查询优化器选择不当，反而降低查询性能。

### 索引类型

MySQL 中包含以下索引类型：

- 主键索引：唯一且不能为 NULL 的索引。
- 唯一索引：唯一索引，不能有重复的值。
- 普通索引：普通索引，可以有重复的值。
- 全文索引：全文索引，用于全文检索。
- 组合索引：组合索引，可以同时使用多个字段进行索引。
    - 我们在创建组合索引时，可以将区分度高的字段放在最左边，这也可以过滤更多数据。

### 原理

MySQL 底层使用 B+树实现主键索引、二级索引。B+树中，所有数据都存放在叶子节点中，而非叶子节点中存放的是索引值。所有叶节点通过链表相连，便于范围查询。

**主键索引**

一种特殊的唯一索引，一个表只能有一个主键，不允许有空值。Innodb 的主键索引又叫聚簇索引，含义是数据行也存储在索引结构中。而
MyISAM 的主键索引则是非聚簇索引，索引结构中仅包含索引值。

**二级索引**

又叫辅助索引，包含唯一/普通/组合/全文索引，一般将非主键索引都叫做二级索引。索引结构中不含数据行，实际查询时需要通过二级索引查询到的数据主键值，再次回到主键索引中查询数据。这个过程叫做
**回表**。

### 为什么选 B+树而不是 B 树

B 树也称 B- 树,全称为多路平衡查找树 ，B+ 树是 B 树的一种变体。B 树和 B+树中的 B 是 `Balanced` （平衡）的意思。

二者最大区别是 B 树的非叶节点也存储了数据行，且叶子节点之间独立；而 B+树的非叶节点只放索引键，只有叶子节点存放数据行，且叶子节点之间是通过链表连接的。

**B+树的优点**

- 更高的空间利用率：非叶节点不存数据，可以保存更多的索引键，这使得整棵树的高度降低，减少查询过程中的 IO 次数。
- 查询路径固定：数据都在叶子节点，因此所有数据访问路径固定为从根节点到叶子节点，查找过程更统一，易于优化和实现。
- 方便范围查询和全表查询：B+树的叶子节点是有序的，并且通过链表链接，而 B 树则要对树做中序遍历。

### 什么是最左匹配原则

最左匹配原则指的是数据库在**使用复合索引**时，会优先考虑索引的最左前缀。只有查询条件中包含了索引的最左列（或最左几列）时，索引才能被利用。

### 一次查询最多使用几个索引

一张表最多使用一个索引，优化器会选择一个最合适的索引。对于多表连接（JOIN）查询时，最多使用的索引数量等于表数量。

### 什么是索引下推

索引下推（Index Condition Pushdown, ICP）是 MySQL 5.6 引入的一项**二级索引**查询优化技术，旨在通过**减少访问表数据的次数**
来提高查询性能。它的基本思想是将部分 WHERE 子句的条件尽量下推到存储引擎层，在存储引擎扫描索引时尽可能多地过滤掉不符合条件的记录，
从而减少传递到 Server 层的数据量。

示例：

```sql
-- 联合索引（name,id）
select *
from t
where name = 'a'
  and xid > 2;
```

**没有索引下推时**

存储引擎只负责使用索引列检索符合**等值**条件的数据，而 WHERE 子句中的非等值条件由 Server 层处理。示例中，引擎层不会对`xid`
字段进行过滤。

**有索引下推时**

存储引擎在检索数据时会考虑非等值条件，这样可以尽量减少传递到 Server 层的数据量，提高查询性能。

**使用索引下推的条件**

- 必须是利用二级索引。
- Where 条件是对索引列进行范围查询/NULL 查询。

**如何验证使用了索引下推**

在 Explain 语句查询结果的 Extra 列中，如果包含`Using index condition`，则表示使用了索引下推。

- [验证索引下推](./mysql_docs/verify_usingindexcond.md)

### 什么是覆盖索引

如果 SQL 选择的索引覆盖了所有涉及的字段，我们就称之为这个 SQL 使用了覆盖索引。比如 Where 条件列都被索引覆盖，但 SELECT
部分未被索引覆盖，
则需要回表查询，增加了 I/O 次数。当然，还包括排序、分组、去重等关键字。

我们可以利用覆盖索引原理，为需要频繁查询/排序/分组等操作的列建立联合索引，以此来减少回表查询次数，提高查询性能。

**如何验证**

通过 Explain 查询结果中的 `Extra` 这一列的 `Using index` ，可以验证成功使用了覆盖索引。

### 创建索引的建议

- 选择合适的字段创建索引：
    - 不为 NULL 的字段：对于数据为 NULL 的字段，数据库较难优化。
    - 被频繁查询的字段：我们创建索引的字段应该是查询操作非常频繁的字段。
    - 被作为条件查询的字段：被作为 WHERE 条件查询的字段，应该被考虑建立索引。
    - 频繁需要排序的字段：索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。
    - 被经常频繁用于连接的字段。
    - 被频繁更新的字段应该慎重建立索引。
- 使用复合索引：对于经常一起使用的多个列，考虑创建复合索引。复合索引可以减少索引的数量，并且在多列条件下更高效。
- 限制每张表上的索引数量：较多的索引会影响写入性能。
- 注意避免冗余索引：避免建立可能被同时命中的索引。

### 查询建议

遵守下面的注意事项，可以尽量避免索引失效。

- 避免使用`select *`：需要回表，降低查询效率。
- 遵守最左匹配原则。
- 避免在索引列上进行函数或计算，这样会阻止索引的使用。
- 避免在模糊查询中将通配符置于最左侧，例如`like '%a'`，`like '_a'`。
- 使用了 OR 查询，但 OR 的前后条件中存在未建立索引的列。
- IN 的取值范围较大时会导致索引失效。
- 避免发生隐式转换，比如索引列是`varchar`类型，而条件使用了`int`类型（而且转换后字面量可能不同！）。

## 事务

### 介绍

事务是并发控制的基本单位。事务主要保证一组连续 SQL 操作的数据完整性和一致性。

事务一般满足四个条件：原子性、一致性、隔离性、持久性。

- 原子性：事务中的所有操作要么全部执行，要么全部不执行。
- 一致性：事务执行之前和执行之后，数据库的完整性没有改变。
- 隔离性：事务之间不能互相干扰（受到隔离级别影响！！！）。
- 持久性：事务执行之后，对数据库的修改是永久的。

隔离级别：

- READ UNCOMMITTED：**最低**的隔离级别，允许脏读，不可重复读和幻读。
- READ COMMITTED：禁止脏读，允许不可重复读和幻读。
- REPEATABLE READ（**默认**）：禁止脏读和不可重复读，允许幻读。
- SERIALIZABLE：**最高**隔离级别，禁止脏读、不可重复读和幻读。

### 事务控制语句

```sql
BEGIN 或
START TRANSACTION -- 显式地开启一个事务；
COMMIT 也可以使用 COMMIT WORK -- 提交事务，二者是等价；
ROLLBACK 也可以使用 ROLLBACK WORK -- 回滚事务，二者是等价；
SAVEPOINT identifier -- 创建一个保存点，用于回滚事务；
RELEASE SAVEPOINT identifier -- 删除一个事务的保存点；
ROLLBACK TO identifier -- 把事务回滚到标记点；
SET AUTOCOMMIT=0/1 -- 禁止/开启自动提交，显式执行事务时关闭；
SELECT @@tx_isolation -- 查看当前事务的隔离级别；
SELECT @@global.tx_isolation; -- 查看全局的事务隔离级别；
SELECT @@transaction_isolation; -- 8.0以上版本
```

设置事务隔离级别：

```sql
-- isolation_level 替换为具体隔离级别
SET SESSION TRANSACTION ISOLATION LEVEL isolation_level;
```

### 实现原理

MySQL 事务用到的技术包含日志文件（redo-log 和 undo-log）、锁和 MVCC，通过这些技术来实现 ACID 特性。

## Explain 优化

### Extra 列

Extra 列显示了 MySQL 在执行查询时采取的一些额外操作或优化策略。

#### Using index

表示 SQL 语句中的查询、排序和分组等关键字涉及到的列都能被**所选择的**索引覆盖。

- [验证 Using index](mysql_docs/verify_usingindex.md)

#### Using where

表示存储引擎返回结果后，Server 层需要再次筛选。这通常是因为 WHERE 条件中包含了无法使用索引的列。

- [验证 Using where](./mysql_docs/verify_usingwhere.md)

#### Using filesort

表示 SQL 语句中包含了排序需求，并且排序字段没有被索引覆盖。这种情况下只能由引擎层返回未排序的索引记录给 Server 层，
后者再调用引擎层接口查询完整记录，再排序，增加了与引擎交互次数。

它与`Using index` 是互斥的，不会同时出现。

- [验证 Using filesort](./mysql_docs/verify_usingfilesort.md)

#### Using temporary

意味着 MySQL 在执行查询时需要创建一个临时表来存储中间结果。这通常发生在查询包含 GROUP BY 和 ORDER BY 子句且这些子句列出不同的列时。

示例：

```sql
-- SQL中的排序字段不在分组字段中，需要临时表来存储分组后的结果，再对其进行排序。
SELECT product_id, SUM(amount) as total_amount
FROM sales
GROUP BY product_id
ORDER BY sale_date;
```

- [验证 Using temporary](./mysql_docs/verify_usingtemporary.md)

## SQL 语句的执行过程

连接器： 身份认证和权限相关(登录 MySQL 的时候)。
查询缓存： 执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）。
分析器： 没有命中缓存的话，SQL 语句就会经过分析器，进行词法分析和语法分析，生成语法树；同时检查对应的表和字段是否存在。
优化器： 负责将语法树转化成执行计划。包括选择不同的索引、决定是否使用子查询或连接操作。
执行器： 由存储引擎执行语句，然后返回数据。

## 为什么不建议单表超过 2000w 数据

TODO

## 常用 SQL

```sql
-- 查看版本
SELECT VERSION();

-- 查看支持引擎列表
SHOW
ENGINES; -- v5.5.5之后innodb成为默认引擎，且只有它支持事务
    
-- 查看默认引擎
SHOW
VARIABLES  LIKE '%storage_engine%';
```

### 优化和检查表

```sql
-- 检查表的完整性
CHECK TABLE table_name;

-- 修复表
REPAIR
TABLE table_name;

-- 分析表，用于更新表的统计信息
ANALYZE
TABLE table_name;

-- 优化表
OPTIMIZE
TABLE table_name;
```

### 备份和恢复

```sql
-- 使用mysqldump工具备份数据库
mysqldump
-u username -p database_name > backup_file.sql

-- 从备份文件恢复数据库
mysql -u username -p database_name < backup_file.sql
```

或使用 GUI 工具。

### 查看表和索引信息

```sql
-- 查看表结构
DESCRIBE table_name;

-- 等同于 DESCRIBE ~
SHOW
COLUMNS FROM table_name;

-- 查看索引信息
SHOW
INDEX FROM table_name;
```

### 监控和性能调优

```sql
-- 查看当前正在执行的查询，不加full只显示前100条。非root用户只看到自己占用的连接
-- 命令详解：https://juejin.cn/post/6856958149027774477
SHOW
[FULL] PROCESSLIST;

-- 查看服务器概况信息，含当前连接信息、用户、服务器版本、client&server字符集、开启线程数、慢查询数、打开表数量、QPS等
STATUS;

-- 获取数据库状态变量信息（只读），GLOBAL关键字仅查看全局状态变量
SHOW
[SESSION|GLOBAL] STATUS;

-- 获取数据库变量信息
SHOW
[SESSION|GLOBAL] VARIABLES;
    
-- 修改变量
SET
[SESSION|GLOBAL] variable_name = value;
```

## 参考

- https://javaguide.cn/database/mysql/mysql-questions-01.html
