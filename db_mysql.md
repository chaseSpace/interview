# MySQL 相关

本文内容部分摘自网络。

## 什么是关系型数据库

一种建立在关系模型的基础上的数据库。关系模型表明了数据库中所存储的数据之间的联系（一对一、一对多、多对多）。
大部分关系型数据库都使用 SQL 来操作数据库中的数据。并且，大部分关系型数据库都支持事务的四大特性(ACID)。

### 常见的关系型数据库

MySQL、PostgreSQL、Oracle、SQL Server、SQLite（微信本地的聊天记录的存储就是用的 SQLite）。

## 字段类型相关

MySQL 字段类型可以简单分为三大类：

- 数值类型：整型（TINYINT、SMALLINT、MEDIUMINT、INT 和 BIGINT）浮点型（FLOAT 和 DOUBLE）、定点型（DECIMAL）
- 字符串类型：CHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT、TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB 等，最常用的是 CHAR 和
  VARCHAR。
- 日期时间类型：YEAR、TIME、DATE、DATETIME 和 TIMESTAMP 等。

### DECIMAL 和 FLOAT/DOUBLE 的区别是什么

DECIMAL 是定点数，FLOAT/DOUBLE 是浮点数。DECIMAL 可以存储精确的小数值，FLOAT/DOUBLE 只能存储近似的小数值。

### DATETIME 和 TIMESTAMP 的区别是什么

DATETIME 类型没有时区信息，TIMESTAMP 和时区有关。

TIMESTAMP 只需要使用 4 个字节的存储空间，但是 DATETIME 需要耗费 8 个字节的存储空间。但是，这样造成了一个问题，Timestamp
表示的时间范围更小。

- DATETIME：`1000-01-01 00:00:00` ~ `9999-12-31 23:59:59`
- Timestamp：`1970-01-01 00:00:01` ~ `2037-12-31 23:59:59`

### 为什么不建议使用 NULL 作为列默认值

- NULL与空字符串不同，NULL 需要更多的存储空间。
- 查询NULL值需要使用专门的SQL语句，比如 `IS NULL`和`IS NOT NULL`，而查询空字符串只需要使用 `=` 或者 `<>` 即可。
- NULL会影响聚合函数的查询结果，例如，SUM、AVG、MIN、MAX 等聚合函数会忽略 NULL 值。
  - COUNT(*) 会包含NULL值所在的行，但 COUNT(col) 不会。
- 查询不便：在查询中使用`NOT IN`或`!=`等反向条件时，查询结果不会包含NULL值所在的行，需要加上`ISNULL(col)`。

注意：DISTINCT 会将多个 NULL 值算作一个 NULL。

> 对于不需要做聚合的字段，可以允许NULL值。

## 存储引擎相关

### 有哪些存储引擎

Innodb 和 MyISAM。使用`SHOW ENGINES`查看支持的引擎列表。

### InnoDB和MyISAM对比

- **锁支持**：MyISAM 是表级锁，InnoDB 支持表级锁和行级锁。
- **事务支持**：只有InnoDB支持事务。
- **外键支持**：只有InnoDB支持外键，但一般不用。
- **崩溃恢复**：只有InnoDB支持。数据库在异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态。这个恢复的过程依赖于
  redo log。
- **MVCC支持**：只有InnoDB支持。这是个废话，因为支持事务才支持MVCC。多版本并发控制，是一种用于实现数据库事务并发控制的技术，可以减少加锁操作，提高性能。
- **索引实现**：都使用 B+Tree 作为索引结构，但实现方式不同。Innodb实现为聚簇索引，即主键索引和数据存储在一起；MyISAM实现为非聚簇索引，即主键索引和数据分开存储。
  - 聚簇索引的叶子节点存储了数据，非聚簇索引的叶子节点存储了数据指针。二级索引的实现没有差别。
- **设置主键**：Innodb一定拥有一个主键，MyISAM可以没有主键。
- **性能差别**：InnoDB 的性能比 MyISAM 更强大。

## 索引

索引是一种用于快速查询和检索数据的数据结构，本质上是一种经过排序的数据结构。

索引底层数据结构存在很多种类型，常见的索引结构有: B 树， B+树 和 Hash、红黑树。在 MySQL 中，无论是 Innodb 还是 MyIsam，都使用了
B+树作为索引结构。

### 优缺点

优点：

- 显著提高查询速度。
- 加速排序和分组操作。
- 强制数据唯一性，确保数据完整性。

缺点：

- 占用额外的存储空间。
- 插入、更新和删除操作可能变慢，因为索引也需要维护。
- 过多的索引可能导致查询优化器选择不当，反而降低查询性能。

### 索引类型

MySQL中包含以下索引类型：

- 主键索引：唯一且不能为 NULL 的索引。
- 唯一索引：唯一索引，不能有重复的值。
- 普通索引：普通索引，可以有重复的值。
- 全文索引：全文索引，用于全文检索。
- 组合索引：组合索引，可以同时使用多个字段进行索引。
  - 我们在创建组合索引时，可以将区分度高的字段放在最左边，这也可以过滤更多数据。

### 原理

MySQL 底层使用B+树实现主键索引、二级索引。B+树中，所有数据都存放在叶子节点中，而非叶子节点中存放的是索引值。所有叶节点通过链表相连，便于范围查询。

**主键索引**

一种特殊的唯一索引，一个表只能有一个主键，不允许有空值。Innodb的主键索引又叫聚簇索引，含义是数据行也存储在索引结构中。而MyISAM的主键索引则是非聚簇索引，索引结构中仅包含索引值。

**二级索引**

又叫辅助索引，包含唯一/普通/组合/全文索引，一般将非主键索引都叫做二级索引。索引结构中不含数据行，实际查询时需要通过二级索引查询到的数据主键值，再次回到主键索引中查询数据。这个过程叫做
**回表**。

### 为什么选B+树而不是B树

B 树也称 B- 树,全称为多路平衡查找树 ，B+ 树是 B 树的一种变体。B 树和 B+树中的 B 是 `Balanced` （平衡）的意思。

二者最大区别是B树的非叶节点也存储了数据行，且叶子节点之间独立；而B+树的非叶节点只放索引键，只有叶子节点存放数据行，且叶子节点之间是通过链表连接的。

**B+树的优点**

- 更高的空间利用率：非叶节点不存数据，可以保存更多的索引键，这使得整棵树的高度降低，减少查询过程中的IO次数。
- 查询路径固定：数据都在叶子节点，因此所有数据访问路径固定为从根节点到叶子节点，查找过程更统一，易于优化和实现。
- 方便范围查询和全表查询：B+树的叶子节点是有序的，并且通过链表链接，而B树则要对树做中序遍历。

### 最左原则是什么

最左原则指的是数据库在**使用复合索引**时，会优先考虑索引的最左前缀。只有查询条件中包含了索引的最左列（或最左几列）时，索引才能被有效利用。

### 一次查询最多使用几个索引

一张表最多使用一个索引，优化器会选择一个最合适的索引。对于多表连接（JOIN）查询时，最多使用的索引数量等于表数量。

### 索引下推是什么

索引下推（Index Condition Pushdown, ICP）是MySQL 5.6引入的一项**二级索引**查询优化技术，旨在通过**减少访问表数据的次数**
来提高查询性能。
它的基本思想是将部分WHERE子句的条件尽量下推到存储引擎层，在存储引擎扫描索引时尽可能多地过滤掉不符合条件的记录，从而减少传递到Server层的数据量。

示例：

```sql
-- 联合索引（name,id）
select *
from t
where name = 'a'
  and xid > 2;
```

**没有索引下推时**

存储引擎只负责使用索引列检索符合**等值**条件的数据，而WHERE子句中的非等值条件由Server层处理。示例中，引擎层不会对`xid`
字段进行过滤。

**有索引下推时**

存储引擎在检索数据时会考虑非等值条件，这样可以尽量减少传递到Server层的数据量，提高查询性能。

**使用索引下推的条件**

- 必须是利用二级索引。
- 查询条件利用了联合索引的多个字段。

**如何验证使用了索引下推**

在Explain语句查询结果的Extra列中，如果包含`Using index condition`，则表示使用了索引下推。

### 覆盖索引

如果一个索引包含（或者说覆盖）所有需要**查询以及排序**的字段的值，我们就称之为覆盖索引。如果查询字段不存在于所利用的索引，则需要回表查询。

简而言之，我们可以利用覆盖索引原理，只选择需要的字段，而不总是`select *`，减少回表查询次数，提高查询性能。

**如何验证**

通过Explain查询结果中的 `Extra` 这一列的 `Using index` ，可以验证成功使用了覆盖索引。

**关于Using Filesort**

如果在Explain查询结果中的 `Extra` 这一列中出现了 `Using filesort` ，则表示SQL语句中包含了排序需求，并且排序字段不包含在使用的索引中，
它和`Using index` 是互斥的，不会同时出现。

### Using where

在Explain查询结果中的 `Extra` 这一列的 `Using where` ，表示存储引擎返回结果后，Server层需要再次筛选，通常是哪些不满足索引下推的情况。

比如：

- WHERE条件中包含了不符合索引下推条件的过滤；
- WHERE条件中包含了非索引列的过滤。

**Using where和Using index同时出现**

表示使用了覆盖索引，但部分条件不满足索引下推，需Server层再次过滤。

### 创建索引的建议

- 选择合适的字段创建索引：
  - 不为 NULL 的字段：对于数据为 NULL 的字段，数据库较难优化。
  - 被频繁查询的字段：我们创建索引的字段应该是查询操作非常频繁的字段。
  - 被作为条件查询的字段：被作为 WHERE 条件查询的字段，应该被考虑建立索引。
  - 频繁需要排序的字段：索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。
  - 被经常频繁用于连接的字段。
  - 被频繁更新的字段应该慎重建立索引。
- 使用复合索引：对于经常一起使用的多个列，考虑创建复合索引。复合索引可以减少索引的数量，并且在多列条件下更高效。
- 限制每张表上的索引数量：较多的索引会影响写入性能。
- 注意避免冗余索引：避免建立可能被同时命中的索引。

### 查询建议

遵守下面的注意事项，可以尽量避免索引失效。

- 避免使用`select *`：需要回表，降低查询效率。
- 遵守最左匹配原则。
- 避免在索引列上进行函数或计算，这样会阻止索引的使用。
- 避免在模糊查询中将通配符置于最左侧，例如`like '%a'`，`like '_a'`。
- 使用了OR查询，但OR的前后条件中存在未建立索引的列。
- IN 的取值范围较大时会导致索引失效。
- 避免发生隐式转换，比如索引列是`varchar`类型，而条件使用了`int`类型（而且转换后字面量可能不同！）。

## 事务

### 介绍

事务是并发控制的基本单位。事务主要保证一组连续SQL操作的数据完整性和一致性。

事务一般满足四个条件：原子性、一致性、隔离性、持久性。

- 原子性：事务中的所有操作要么全部执行，要么全部不执行。
- 一致性：事务执行之前和执行之后，数据库的完整性没有改变。
- 隔离性：事务之间不能互相干扰（受到隔离级别影响！！！）。
- 持久性：事务执行之后，对数据库的修改是永久的。

隔离级别：

- READ UNCOMMITTED：**最低**的隔离级别，允许脏读，不可重复读和幻读。
- READ COMMITTED：禁止脏读，允许不可重复读和幻读。
- REPEATABLE READ（**默认**）：禁止脏读和不可重复读，允许幻读。
- SERIALIZABLE：**最高**隔离级别，禁止脏读、不可重复读和幻读。

### 事务控制语句

```sql
BEGIN 或
START TRANSACTION -- 显式地开启一个事务；
COMMIT 也可以使用 COMMIT WORK -- 提交事务，二者是等价；
ROLLBACK 也可以使用 ROLLBACK WORK -- 回滚事务，二者是等价；
SAVEPOINT identifier -- 创建一个保存点，用于回滚事务；
RELEASE SAVEPOINT identifier -- 删除一个事务的保存点；
ROLLBACK TO identifier -- 把事务回滚到标记点；
SET AUTOCOMMIT=0/1 -- 禁止/开启自动提交，显式执行事务时关闭；
SELECT @@tx_isolation -- 查看当前事务的隔离级别；
SELECT @@global.tx_isolation; -- 查看全局的事务隔离级别；
SELECT @@transaction_isolation; -- 8.0以上版本
```

设置事务隔离级别：

```sql
-- isolation_level 替换为具体隔离级别
SET SESSION TRANSACTION ISOLATION LEVEL isolation_level;
```

### 实现原理

## SQL语句的执行过程

连接器： 身份认证和权限相关(登录 MySQL 的时候)。
查询缓存： 执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）。
分析器： 没有命中缓存的话，SQL 语句就会经过分析器，进行词法分析和语法分析，生成语法树；同时检查对应的表和字段是否存在。
优化器： 负责将语法树转化成执行计划。包括选择不同的索引、决定是否使用子查询或连接操作。
执行器： 由存储引擎执行语句，然后返回数据。

## MySQL架构分层是怎样的

TODO

## 为什么不建议单表超过2000w数据

TODO

## 常用SQL

```sql
-- 查看版本
SELECT VERSION();

-- 查看支持引擎列表
SHOW
ENGINES; -- v5.5.5之后innodb成为默认引擎，且只有它支持事务
    
-- 查看默认引擎
SHOW
VARIABLES  LIKE '%storage_engine%';
```

### 优化和检查表

```sql
-- 检查表的完整性
CHECK TABLE table_name;

-- 修复表
REPAIR
TABLE table_name;

-- 分析表，用于更新表的统计信息
ANALYZE
TABLE table_name;

-- 优化表
OPTIMIZE
TABLE table_name;
```

### 备份和恢复

```sql
-- 使用mysqldump工具备份数据库
mysqldump
-u username -p database_name > backup_file.sql

-- 从备份文件恢复数据库
mysql -u username -p database_name < backup_file.sql
```

或使用GUI工具。

### 查看表和索引信息

```sql
-- 查看表结构
DESCRIBE table_name;

-- 等同于 DESCRIBE ~
SHOW
COLUMNS FROM table_name;

-- 查看索引信息
SHOW
INDEX FROM table_name;
```

### 监控和性能调优

```sql
-- 查看当前正在执行的查询，不加full只显示前100条。非root用户只看到自己占用的连接
-- 命令详解：https://juejin.cn/post/6856958149027774477
SHOW
[FULL] PROCESSLIST;

-- 查看服务器概况信息，含当前连接信息、用户、服务器版本、client&server字符集、开启线程数、慢查询数、打开表数量、QPS等
STATUS;

-- 获取数据库状态变量信息（只读），GLOBAL关键字仅查看全局状态变量
SHOW
[SESSION|GLOBAL] STATUS;

-- 获取数据库变量信息
SHOW
[SESSION|GLOBAL] VARIABLES;
    
-- 修改变量
SET
[SESSION|GLOBAL] variable_name = value;
```

## 参考

- https://javaguide.cn/database/mysql/mysql-questions-01.html
