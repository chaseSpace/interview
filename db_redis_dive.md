# Redis 深度面试

## 开篇：Redis所有数据结构

| 数据结构   | Redis 实现                     |
|--------|------------------------------|
| String | SDS                          |
| List   | LinkedList/ZipList/QuickList |
| Hash   | Dict、ZipList                 |
| Set    | Dict、Intset                  |
| ZSet   | ZipList、SkipList             |

## 1. 基础认知

### Redis 6.x是单线程吗

Redis 6.x 并不是完全的单线程。准确来说，Redis 的命令解析与处理是单线程的，但 Redis 6.x 引入了多线程来处理一些辅助操作。

具体来说：

- **核心处理线程**：命令在内存中的解析和执行部分仍然使用主线程（单线程），保证了命令执行的原子性
- **多线程辅助**：Redis 6.x 引入了多线程来处理网络 I/O 的读写，即在网络数据读取和写回时使用多线程
- **后台线程**：持久化操作（如 RDB）、某些删除操作（lazy free）等使用后台线程处理

这种设计既保持了单线程的简单性和原子性优势，又提升了 I/O 性能。

### 详细分析一次Redis操作的内部过程

一次 Redis 操作的完整过程如下：

1. **客户端连接**：客户端通过 socket 连接到 Redis 服务器
2. **网络读取**：Redis 从 socket 中读取客户端发送的命令（在 6.x 中可能使用多线程）
3. **命令解析**：Redis 解析协议格式的命令，提取命令名和参数
4. **命令调度**：将命令加入处理队列（单线程处理）
5. **命令执行**：根据命令类型调用相应处理函数，在内存中操作数据结构
6. **结果生成**：生成命令执行结果的协议格式
7. **网络写回**：将结果写回客户端（在 6.x 中可能使用多线程）

整个过程中，只有第 3-6 步是单线程处理，保证了数据一致性。

### Redis 持久化是怎样的，会存在数据丢失吗

Redis 提供了两种持久化方式：

**RDB（Redis Database）**：

- 原理：在指定时间间隔内对内存中的数据生成快照并保存到磁盘
- 优点：文件紧凑，适合备份和恢复
- 缺点：可能会丢失最后一次快照后到故障前的数据
- 触发方式：手动执行 SAVE/BGSAVE 命令或配置自动触发
    - 配置格式：`save <seconds> <changes>`，例如 `save 900 1`，表示 900 秒内至少有 1 个命令修改了数据，就会生成快照

**AOF（Append Only File）**：

- 原理：记录每一个写命令到日志文件，重启时重放命令恢复数据
- 优点：数据丢失少，可读性好
- 缺点：文件体积大，恢复速度慢
- 写入策略：always（每次写入都持久化）、everysec（每秒写入一次）、no（由操作系统决定）

**混合持久化（Redis 4.0+）**：

- 结合 RDB 和 AOF 的优点，使用 RDB 作为基础数据，AOF 记录增量命令

数据丢失场景：

- RDB 模式：最后一次快照后的数据会丢失
- AOF always 策略：基本不会丢失数据，但性能较差
- AOF everysec 策略：可能丢失 1 秒内的数据
- AOF no 策略：系统崩溃时可能丢失较多数据

### Redis Key Value最大可以多大？

Redis 中 Key 和 Value 的最大限制如下：

**Key**：

- 最大长度：512MB
- 最佳实践：建议控制在 1KB 以内
- 要求：必须是字符串类型

**Value**：

- 最大长度：512MB
- 不同数据类型的实际限制：
    - String：最大 512MB
    - List、Set、Hash、ZSet：元素的 value 最大 512MB
    - 整体数据结构的大小受限于内存

**实际考虑**：

- 过大的 Key 会影响查找效率
- 过大的 Value 会阻塞 Redis 单线程（big key 问题）
- 建议 Value 控制在 10KB 以内以保证性能
- 如果需要存储大对象，建议拆分或使用外部存储

## 2. 数据类型——String

### String 底层如何实现的

Redis 中的 String 类型底层使用简单动态字符串（Simple Dynamic String，SDS）实现，而不是 C 语言的原生字符串。

SDS 的结构定义包含：

- `len`：记录 SDS 中已使用字节数，即字符串长度
- `alloc`：记录 SDS 分配的总字节数，不包括头部和 null 终止符
- `flags`：记录 SDS 类型，区分不同长度的 SDS
- `buf[]`：字节数组，实际存储字符串内容

SDS 有多种类型，根据字符串长度使用不同大小的头部：

- `struct sdshdr5`：用于长度小于 2^5 的字符串
- `struct sdshdr8`：用于长度小于 2^8 的字符串
- `struct sdshdr16`：用于长度小于 2^16 的字符串
- `struct sdshdr32`：用于长度小于 2^32 的字符串
- `struct sdshdr64`：用于长度小于 2^64 的字符串

通过这种设计，Redis 能够根据字符串长度选择最节省内存的 SDS 类型。

### SDS 是什么？解决了 C 字符串的哪些问题？

SDS（Simple Dynamic String）是 Redis 自定义的动态字符串实现，相比 C 语言的原生字符串，解决了以下问题：

**1. 获取字符串长度的时间复杂度问题**

- C 字符串：O(n)，需要遍历整个字符串直到遇到空字符
- SDS：O(1)，通过 `len` 属性直接获取

**2. 缓冲区溢出问题**

- C 字符串：在拼接操作时可能导致缓冲区溢出
- SDS：通过预分配策略和空间释放策略防止溢出

**3. 减少内存分配次数**

- C 字符串：每次修改都需要重新分配内存
- SDS：采用空间预分配和惰性空间释放策略

**4. 二进制安全问题**

- C 字符串：以空字符结尾，不能存储包含空字符的数据
- SDS：通过 `len` 属性判断字符串边界，支持二进制数据

**5. 兼容部分 C 字符串函数**

- SDS 的 buf 数组仍以空字符结尾，可兼容部分 C 字符串函数

### SDS 的 len 和 alloc 有什么作用？

SDS 中 `len` 和 `alloc` 字段的作用如下：

**len 字段**：

- 记录 SDS 已使用的字节数，即字符串的实际长度
- 用于 O(1) 时间复杂度获取字符串长度
- 在字符串修改操作中实时更新

**alloc 字段**：

- 记录 SDS 分配的总字节数，不包括头部和 null 终止符
- 用于记录分配给字符串的总空间大小
- 通过 `alloc - len` 可以计算出未使用的空间大小

这两个字段使得 SDS 能够：

- 高效获取字符串长度
- 预分配额外空间避免频繁内存分配
- 实现惰性空间释放策略
- 进行内存使用情况的统计和管理

### String 最大 512MB，底层是一次性连续内存吗？

Redis String 类型的最大容量确实是 512MB，但其内存分配策略如下：

**内存分配方式**：

- Redis String 底层确实使用连续的内存块存储
- 一次性分配足够大的连续内存空间
- 但会根据预分配策略分配比实际需要更多的空间

**预分配策略**：

- 当 SDS 需要增长时，如果新长度小于 1MB，分配与新长度相同的额外空间
- 当新长度大于等于 1MB 时，分配 1MB 的额外空间
- 这种策略减少了频繁的内存重分配

**大字符串处理**：

- 512MB 是 Redis String 类型的硬性限制
- 实际上，如此大的字符串会影响 Redis 性能（big key 问题）
- 大字符串操作会阻塞主线程，影响其他请求的处理

**内存管理**：

- Redis 使用内存池和内存分配器（如 jemalloc）优化内存分配
- 大块内存的分配和释放由底层内存分配器管理

## 3. 数据类型——List

### List 底层用的是什么数据结构？

Redis 的 List 类型底层使用 `quicklist` 数据结构实现。

在 Redis 3.2 之前，List 使用双向链表（linkedlist）+压缩列表（ziplist）实现：

- **双向链表**：插入删除快，但内存开销大，每个节点需要存储前后指针
- **压缩列表**：内存紧凑，但查找慢，插入删除可能需要大量数据移动（连锁更新）

从 Redis 3.2 开始，统一使用 `quicklist` 作为 List 的底层实现，它结合了双向链表和压缩列表的优点。

> 从 Redis 7.0 开始， ZipList 被 ListPack 取代。

### 详细介绍 linkedlist + ziplist 的组合实现

根据二者的优缺点，Redis 在创建List时先使用 ziplist，而后在元素较多或新的字符串元素较大时，替换为 linkedlist。

### quicklist 是什么？

`quicklist` 是 Redis 自定义的数据结构，本质上是一个双向链表，但链表的每个节点存储的是 `ziplist`（压缩列表）。

设计 `quicklist` 的原因：

- **内存效率**：相比纯双向链表，每个节点存储多个元素，减少了节点指针的内存开销
- **访问效率**：`ziplist` 中的元素在内存中连续存储，提高了缓存命中率
- **平衡设计**：在内存使用和操作性能之间取得平衡

`quicklist` 的结构包含：

- `head` 和 `tail`：指向首尾节点的指针
- `count`：列表中元素总数
- `len`：quicklist 节点数量
- `fill`：ziplist 节点的填充因子
- `compress`：压缩深度

### 每个操作的时间复杂度是多少？

Redis List 各个操作的时间复杂度如下：

**头尾操作（O(1)）**：

- **lpush/rpush**：在列表头/尾插入元素，O(1)
- **lpop/rpop**：从列表头/尾弹出元素，O(1)
- **lpushx/rpushx**：在存在的列表头/尾插入元素，O(1)

**索引访问（O(N)）**：

- **lindex**：获取指定索引的元素，O(N)，需要遍历到指定位置
- **lset**：设置指定索引的元素值，O(N)，需要先定位到位置

**范围操作（O(N)）**：

- **lrange**：获取指定范围的元素，O(N)，N是获取的元素个数
- **ltrim**：修剪列表，O(N)，N为被移除元素个数

**查找操作（O(N)）**：

- **lpos**：查找指定元素的第一个索引，O(N)，需要遍历列表
- **lrem**：移除指定值的元素，O(N)，需要遍历整个列表

**长度操作（O(1)）**：

- **llen**：获取列表长度，O(1)，通过 quicklist 的 count 属性直接获取

**阻塞操作（O(1)）**：

- **blpop/brpop**：阻塞式弹出，O(1)，与非阻塞版本相同

这些复杂度的原理：

- 头尾操作通过 head 和 tail 指针直接访问，因此为 O(1)
- 索引相关操作需要遍历到指定位置，因此为 O(N)
- 范围操作需要访问多个元素，因此为 O(N)
- 长度查询通过保存的计数器直接返回，因此为 O(1)

### List 和 Stream 的核心区别是什么？

Redis List 和 Stream 是两种不同的数据结构，主要区别如下：

**用途差异**：

- **List**：简单的队列/栈结构，用于消息队列、任务队列等
- **Stream**：专门的流数据结构，用于消息流处理、事件日志等

**数据模型**：

- **List**：简单的字符串列表，每个元素是字符串值
- **Stream**：键值对消息，每个消息包含多个字段和值

**消费模式**：

- **List**：消费者直接弹出消息，消息被消费后消失
- **Stream**：支持消费者组，消息可以被多个消费者组消费，支持消息确认机制

**持久性**：

- **List**：简单的数据结构，不具备消息持久化特性
- **Stream**：天然支持消息持久化，具有更完善的消息管理功能

**功能特性**：

- **List**：基本的队列操作（lpush/rpush/lpop/rpop）
- **Stream**：丰富的流操作（XADD/XREAD/XGROUP等），支持消息ID、消费者组等

### List 能不能当队列？有什么坑？

Redis List 可以用作队列，但需要注意以下问题：

**可以实现的队列类型**：

- **FIFO 队列**：LPUSH + RPOP 或 RPUSH + LPOP
- **栈结构**：LPUSH + LPOP 或 RPUSH + RPOP

**存在的坑和问题**：

1. **消息丢失风险**：
    - 使用 RPOP/LPOP 弹出消息后，如果消费者处理失败，消息会永久丢失
    - Redis 宕机时，可能有未持久化的消息丢失
    - 没有消息确认机制

2. **阻塞操作**：
    - BRPOP/BLPOP 虽然支持阻塞等待，但没有消费者组概念
    - 无法实现负载均衡的消费者模式

3. **持久性问题**：
    - 重启后可能丢失正在处理的消息
    - 没有类似 Stream 的消息 ID 机制

4. **性能问题**：
    - 大 List 操作可能阻塞主线程
    - 没有分片机制处理大容量队列

**建议**：

- 对于简单的任务队列，List 可以胜任
- 对于需要高可靠性、监控、消费者组的消息队列，建议使用 Redis Stream
- 可以结合 BRPOP/BLPOP 实现阻塞式队列，但要考虑消息丢失问题

## 4. 数据类型——Hash

### Hash 使用什么底层数据结构？

Redis Hash 类型有两种底层数据结构：

**1. ziplist（压缩列表）**

- 当满足以下条件时使用：
    - Hash 中字段数量不超过 `hash-max-ziplist-entries`（默认 512）
    - Hash 中所有值的长度都不超过 `hash-max-ziplist-value`（默认 64 字节）
- 存储结构紧凑，内存效率高
- 每个字段-值对在 ziplist 中连续存储

**2. hashtable（哈希表）**

- 不满足 ziplist 条件时自动转换为 hashtable
- 使用字典（dict）数据结构实现
- 支持更大的数据量和更复杂的操作
- 查找、插入、删除操作平均时间复杂度为 O(1)

Hash 对象的结构转换是单向的，只能从 ziplist 转为 hashtable，不能逆向转换。

### 如何解决哈希冲突的？

Redis 中的 Hash 类型使用字典（dict）作为 hashtable 实现，采用以下方式解决哈希冲突：

**链地址法（Separate Chaining）**：

- 每个哈希桶（bucket）对应一个链表
- 哈希值相同的键值对被链接到同一个链表中
- 查找时先定位到哈希桶，然后在链表中遍历查找

**具体实现**：

- `dictEntry` 结构包含：
    - `key`：键
    - `v`：值
    - `next`：指向下一条目的指针
- 发生冲突时，新条目插入到链表头部

**rehash 过程中的冲突处理**：

- 在渐进式 rehash 期间，可能同时存在两个哈希表
- 查找时先在主哈希表查找，未找到再到迁移表查找
- 插入时只插入到主哈希表

### 什么是渐进式 rehash？

渐进式 rehash 是 Redis 为避免一次性 rehash 操作导致长时间阻塞而采用的一种分步迁移策略。当哈希表需要扩容或缩容时，
Redis 不会一次性将所有键值对迁移到新的哈希表，而是将这个迁移工作分散到多次操作中完成。

**基本原理**：

- 将原本 O(N) 的一次性迁移操作分解为多次小步骤执行
- 每次处理一小部分数据，避免长时间占用主线程
- 保证在 rehash 过程中服务的连续性

**触发条件**：

- 哈希表的负载因子大于 1（链表过长影响性能）
- 或者负载因子小于 0.1 且节点数量大于 4（节省内存）

**渐进式 rehash 过程**：

1. **初始化**：分配一个新的哈希表（ht[1]），大小根据 rehash 目的确定
2. **标记状态**：将字典的 rehashidx 设置为 0，表示开始 rehash
3. **分步迁移**：
    - 每次 Hash 命令执行时迁移一个桶（bucket）的所有条目
    - 将 ht[0] 中索引为 rehashidx 的桶的所有条目迁移到 ht[1]
    - rehashidx 递增，处理下一个桶
4. **查询处理**：
    - 查找时先在 ht[0] 查找，未找到再到 ht[1] 查找
    - 插入只插入到 ht[1]
5. **完成迁移**：
    - 当所有桶都迁移完成后，用 ht[1] 替换 ht[0]
    - 释放原哈希表内存
    - rehashidx 设置为 -1

**关键特点**：

- **渐进性**：迁移工作分散到多次操作中
- **连续性**：rehash 过程中服务不中断
- **一致性**：保证数据的完整性和正确性

## 5. 数据类型——Set

### Set 的底层编码有哪些？

### intset 是什么？为什么比普通 set 省内存？

### intset 如何升级？会降级吗？

### sadd 时间复杂度是多少？

### Set 和 Hash 的使用场景对比？

## 6. 数据类型——ZSet

### ZSet 为什么同时使用 skiplist + dict？

### skiplist 的时间复杂度？为什么不用红黑树？

### ZSet 中 score 相同怎么办？

### ZSet 的范围查询为什么快？

### ZSet 的内存占用为什么比较大？

## 7. 内存模型与性能

### Redis 对象（redisObject）结构是什么？

### Redis 如何区分不同数据类型？

### 什么是对象共享池？

### 内存碎片是如何产生的？

### jemalloc 在 Redis 中的作用？

### 什么是 lazy free？

### big key 会带来什么问题？

### Redis 里有哪些 O(n) 命令？为什么危险？