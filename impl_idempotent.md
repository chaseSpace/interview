# 幂等有几种实现方式

本文尝试围绕软件工程中的幂等概念展开进行解释。

## 什么是幂等

幂等是指一次和多次调用某一个接口应该具有同样的结果。也就是说，对于同一种行为，如果执行不论多少次，最终的结果都是一致相同的，
就称这种行为是幂等的。在编程语言中，函数是幂等性的完美体现，不过面试中通常指的是幂等接口。

此外，与幂等高度相似的另一个设计是**防重**。

## 防重与幂等

防重与幂等是软件工程中两个存在交叉的处理重复提交的设计理念。**防重**是为了避免重复提交产生（不希望的）重复或错误的数据。
**幂等**在防重的基础上，还要求在相同参数的情况下服务端必须返回相同的结果。

**本质**

将所有场景抽象后，最终都是避免同一数据的**重复更新**或**重复创建**，
所以都要求业务提供唯一性参数，可以是联合唯一（多字段组合）。

**相同点**

防重与幂等的相同点在于都需要处理重复请求，所以它们的应用场景基本一致，但侧重点不同。

**不同点**

防重是针对客户端的，其解决方案可以返回错误信息，例如提示用户重复提交。
而幂等是针对服务端的，要求服务端必须返回相同的结果。具体场景中，采用防重还是幂等取决于我们的侧重点。

**触发场景**

- 前端重复提交：用户可能重复操作或刷新页面，可能导致表单重复提交，系统应保证这些操作只执行一次。
- 消息重复消费：在使用分布式消息队列时，可能会发生消息重复消费的情况，系统需要确保即使消息被重复处理，也不会影响最终状态。
- 定时任务设置不合理：如果定时任务配置不当，可能会导致数据被重复处理。幂等性设计可以确保即使任务重复执行，也不会产生错误的影响。
- 接口重试机制：例如 Nginx 重试、RPC 通信重试或业务层重试等，可能导致请求被多次执行。系统需要能够处理这些重复的调用。
- 并发调用。

**要求幂等的场景示例**

- 领红包：一个用户对于同一个红包，领多次与领一次的效果相同。
- 创建订单：同一时间同一页面的下单按钮，点多次和点一次的效果相同。
- 订单状态变更：同一时间同一页面的「确认收货」按钮，点多次和点一次的效果相同。
- 消息消费：同一消息 ID 的消息，消费多次和消费一次的效果相同。

## 解决方案

防重和幂等都首先要求请求来源提供一个**唯一性参数**，其次是根据场景来选择合适的方案。下面是一些常见的方案以及对应场景。

- Token 机制：适用于创建数据的场景，例如创建订单。
- 数据库唯一索引：适用于使用数据库创建数据的场景，例如创建订单、抢红包、消息消费。
- 乐观锁：适用于冲突概率低的更新数据的场景，例如订单更新。
- 悲观锁：适用于冲突概率高、重试成本高或者无法使用其他方案的场景，例如仅用内存实现的游戏进房、换座位操作。

幂等在防重的基础上需要额外做一些查询的步骤，即查询该唯一参数的操作结果。

### 1. Token 机制

此方案采用类似令牌桶的设计，要求每个请求携带一个唯一 Token，服务器保证每个 Token 只能使用一次（Token 一般也是由服务器提供）。
具体步骤：

1. 客户端在前续步骤（如下单流程中的「填写各项订单」步骤）中从服务器获取一个唯一 Token（服务器生成唯一 ID 放在缓存中，并设置过期）；
2. 客户端在点击提交按钮时，携带 Token 提交请求；
3. 服务器通过一种**原子性操作**从缓存中查询并取出 Token，如可以获取到 Token，则允许执行后续步骤。否则中断执行，因为 Token
   已使用或已过期；

其中唯一 ID 生成可以采用雪花算法；原子性的**查询并取出 Token**可以使用 Redis 的 Lua 脚本实现。

Token 机制一般应用在包含一个或多个**前续步骤**的事务场景中，比如用户下单需要先填写收货地址等信息，再提交订单。

### 2. 数据库唯一索引

几乎所有需要幂等的场景都可以采用数据库唯一索引来保证事务的唯一性。具体步骤是在数据表中为业务的唯一参数列（可能是多列组合）添加一个唯一索引，
然后在创建数据时通过数据库是否返回对应错误码来判断是否**创建过**。

### 3. 乐观锁和悲观锁

这两种锁原本是用于解决并发冲突问题，但也可以用来解决幂等问题。

简单介绍两种锁：

- 乐观锁通过版本号或 CAS 机制实现，它避免使用显式的锁机制，以提高整体吞吐量，适用于冲突较少的场景。
- 悲观锁通过显式的锁机制实现，以减少大量无效的操作，适用于冲突较多的场景。

#### 3.1 乐观锁

比如在更新订单状态的场景中，通过将状态从 A 改为 B 时，并且只允许更新一次。通常的做法是在 UPDATE 语句的 WHERE 条件中包含对状态
A 的判断，
如果影响行数为 0，则表示状态已经更新过了，否则表示更新成功。然后执行后续的逻辑。这种做法其实本质上就是一种基于 CAS 的乐观锁，
但它较一般的乐观锁没有重试的逻辑。

#### 3.2 悲观锁

同样是在更新订单状态的场景中，我们还可以选择先锁住订单（使用`FOR UPDATE`排他锁），然后在事务中更新订单状态以及执行后续的逻辑。
但一般不会这么去做，因为更新订单的并发冲突概率很小。

另一个场景是仅用内存实现的游戏进房、换座位操作。此时一般使用**分布式锁**作为具体实现，然后检查状态是否已经变更，
在没有变更的前提下执行相应的操作以及后续逻辑，若已经变更则返回相应提示。

> [!NOTE]
> 由于场景应用差异，在幂等设计中，较少使用悲观锁。