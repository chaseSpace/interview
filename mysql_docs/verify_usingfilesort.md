## 验证 Explain 结果中的 Using filesort

## 理论

在 MySQL 中，Explain 结果中 Extra 列显示`Using filesort`，表示查询无法通过索引直接获取排序结果，需要额外排序操作。

**官方文档**

在[MySQL 5.7 官方文档 Extra](https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain-extra-information)
的页面中精确搜索`Using filesort`关键字。

无法通过索引直接获取排序结果的情况：

- 排序字段完全无索引
- 排序字段不满足最左前缀，且未使用的索引部分也不是常量条件
- 多字段排序顺序不一致（一个字段是升序，另一个是降序）
- 排序字段跨多个索引
- 查询字段与索引字段不匹配
- 排序字段使用了函数或表达式（例如 `LOWER(name)`，`-age`）
- GROUP BY 和 ORDER BY 字段不匹配
- 仅对列的部分字节建立索引
- 索引选择性低，优化器认为全表扫描比索引扫描更快

其他不常见的情况，如索引不按顺序存储行（例如，对于 MEMORY 表中的 HASH 索引）。

## filesort原理

MySQL为每个会话分配`sort_buffer_size`大小的内存来实现filesort，这个配置可以修改。当这个配置空间不足以满足查询结果的排序需求时，
MySQL会使用创建临时磁盘文件来协助完成排序。

### 优化

变量`max_length_for_sort_data`控制触发filesort的阈值，如果配置过大，则更多的索引无法完成的排序会使用临时文件来完成，会增加磁盘
IO 且降低 OrderBy 性能。

## 准备环境

参照[教程](#准备环境)准备MySQL环境。

## 正例1：排序字段完全无索引

```
mysql> explain select age from employees order by age limit 10;
+----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+----------------+
| id | select_type | table     | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra          |
+----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+----------------+
|  1 | SIMPLE      | employees | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 998337 |   100.00 | Using filesort |
+----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+----------------+
1 row in set (0.02 sec)
```

## 正例2：排序字段不满足最左前缀，且未使用的索引部分也不是常量条件

已有索引是`idx_department_salary (department, salary)`，所以下面查询无法使用索引。

```
mysql> explain select salary from employees order by salary limit 10;
+----+-------------+-----------+------------+-------+---------------+-----------------------+---------+------+--------+----------+-----------------------------+
| id | select_type | table     | partitions | type  | possible_keys | key                   | key_len | ref  | rows   | filtered | Extra                       |
+----+-------------+-----------+------------+-------+---------------+-----------------------+---------+------+--------+----------+-----------------------------+
|  1 | SIMPLE      | employees | NULL       | index | NULL          | idx_department_salary | 59      | NULL | 992343 |   100.00 | Using index; Using filesort |
+----+-------------+-----------+------------+-------+---------------+-----------------------+---------+------+--------+----------+-----------------------------+
1 row in set (0.04 sec)
```

如果未使用的索引部分(`department`)是常量条件，则可以使用index排序：

```
mysql> explain select salary from employees where department = 'dev' order by salary limit 10;
+----+-------------+-----------+------------+------+-----------------------+-----------------------+---------+-------+------+----------+--------------------------+
| id | select_type | table     | partitions | type | possible_keys         | key                   | key_len | ref   | rows | filtered | Extra                    |
+----+-------------+-----------+------------+------+-----------------------+-----------------------+---------+-------+------+----------+--------------------------+
|  1 | SIMPLE      | employees | NULL       | ref  | idx_department_salary | idx_department_salary | 53      | const |    1 |   100.00 | Using where; Using index |
+----+-------------+-----------+------------+------+-----------------------+-----------------------+---------+-------+------+----------+--------------------------+
1 row in set (0.04 sec)
```

## 正例3：多字段排序顺序不一致

这种方式违反了单颗索引树的规则，所以无法使用索引排序。

```
mysql> explain select department from employees order by department desc ,salary asc limit 10;
+----+-------------+-----------+------------+-------+---------------+-----------------------+---------+------+--------+----------+-----------------------------+
| id | select_type | table     | partitions | type  | possible_keys | key                   | key_len | ref  | rows   | filtered | Extra                       |
+----+-------------+-----------+------------+-------+---------------+-----------------------+---------+------+--------+----------+-----------------------------+
|  1 | SIMPLE      | employees | NULL       | index | NULL          | idx_department_salary | 59      | NULL | 992343 |   100.00 | Using index; Using filesort |
+----+-------------+-----------+------------+-------+---------------+-----------------------+---------+------+--------+----------+-----------------------------+
1 row in set (0.04 sec)
```

## 正例4：排序字段跨多个索引

```
mysql> explain select name from employees order by name, department limit 10;
+----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+----------------+
| id | select_type | table     | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra          |
+----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+----------------+
|  1 | SIMPLE      | employees | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 992343 |   100.00 | Using filesort |
+----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+----------------+
1 row in set (0.04 sec)
```

## 正例5：查询字段与索引字段不匹配

注意，这个例子SQL没有LIMIT，
如果有LIMIT就可以使用索引排序。首先，这个SQL可能会使用到2个索引（之一），如果加LIMIT，那么优化器会使用`idx_name`
索引来完成排序（因为这样更优），
然后回表查出`department`字段。如不加LIMIT，则由于要查询和排序的数据过多，选不出最优索引，最终选择全表扫描再排序。

```
mysql> explain select department from employees order by name;
+----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+----------------+
| id | select_type | table     | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra          |
+----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+----------------+
|  1 | SIMPLE      | employees | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 998337 |   100.00 | Using filesort |
+----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+----------------+
1 row in set (0.03 sec)
```

## 正例6：排序字段使用了函数或表达式

```
mysql> explain select name from employees order by LOWER(name) limit 10;
+----+-------------+-----------+------------+-------+---------------+----------+---------+------+--------+----------+-----------------------------+
| id | select_type | table     | partitions | type  | possible_keys | key      | key_len | ref  | rows   | filtered | Extra                       |
+----+-------------+-----------+------------+-------+---------------+----------+---------+------+--------+----------+-----------------------------+
|  1 | SIMPLE      | employees | NULL       | index | NULL          | idx_name | 53      | NULL | 992343 |   100.00 | Using index; Using filesort |
+----+-------------+-----------+------------+-------+---------------+----------+---------+------+--------+----------+-----------------------------+
1 row in set (0.04 sec)
```

## 正例7：GROUP BY 和 ORDER BY 字段不匹配

```

mysql> explain select department from employees group by department,salary order by salary;
+----+-------------+-----------+------------+-------+-----------------------+-----------------------+---------+------+-------+----------+----------------------------------------------+
| id | select_type | table     | partitions | type  | possible_keys         | key                   | key_len | ref  | rows  | filtered | Extra                                        |
+----+-------------+-----------+------------+-------+-----------------------+-----------------------+---------+------+-------+----------+----------------------------------------------+
|  1 | SIMPLE      | employees | NULL       | index | idx_department_salary | idx_department_salary | 59      | NULL | 99737 |   100.00 | Using index; Using temporary; Using filesort |
+----+-------------+-----------+------------+-------+-----------------------+-----------------------+---------+------+-------+----------+----------------------------------------------+
1 row in set (0.04 sec)
```

## 正例8：仅对列的部分字节建立索引

省略。

## 正例X：索引选择性低，优化器认为全表扫描比索引扫描更快

参考[正例5](#正例5查询字段与索引字段不匹配)。