# 设计模式篇

在软件工程中，设计模式（design pattern）是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案，最初从建筑行业引入。

24 种设计模式有三种分类：创建型模式、结构型模式、行为型模式。

- 创建型模式：对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离。
    - （6 种）简单工厂模式、工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式
- 结构型模式：关注于对象的组成以及对象之间的依赖关系，描述如何将类或者对象结合在一起形成更大的结构。
    - （7 种）适配器模式、装饰者模式、代理模式、外观模式、桥接模式、组合模式、享元模式
- 行为型模式：关注于对象的行为问题，是对在不同的对象之间划分责任和算法的抽象化；不仅仅关注类和对象的结构，而且重点关注它们之间的相互作用。
    - （11 种）策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式

## 创建型模式

### 1. 简单工厂模式

简单工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。

**核心**：一个工厂类生产一类产品，这类产品都实现了同一个产品接口。

Go 语言没有 Java/Python 中的构造函数概念（也就没有工厂类概念），一般都是定义 `NewXXX` 函数来初始化相关产品或类。
可以将 `NewXXX` 叫做工厂函数。

示例：[dp_simplefactory.go](design_pattern/dp_simplefactory.go)

### 2. 工厂方法模式

工厂方法模式（Factory Method Pattern）是简单工厂模式的进一步抽象。

**核心**：一个工厂接口+多个工厂类，每个工厂类负责生产一类产品。

示例：[dp_factorymethod.go](design_pattern/dp_factorymethod.go)

> [!NOTE]
> 工厂方法模式比简单工厂模式多了一个工厂接口。

### 3. 抽象工厂模式

在简单工厂和工厂方法模式中，我们都只需生产一类产品，比如只生产（各种品牌的）电池。
但有时候，我们需要生产多类（有关联的）产品，它们属于不同产品线，比如需要生产（各种品牌的）电池和屏幕。
此时，抽象工厂模式就可以派上用场了。

在抽象工厂模式中，首先有一个超级工厂接口，它可以生产多个产品线的工厂类，然后产出的这些工厂类再生产出对应的产品。

例如有一个生产电池和屏幕的超级工厂接口，具体的超级工厂可以是三星超级工厂、小米超级工厂等。
一个三星超级工厂拥有生产三星牌电池和屏幕的产品线，一个小米超级工厂拥有生产小米牌电池和屏幕的产品线。

**核心**： 一个超级工厂接口+多个子工厂类，每个子工厂类生产一类产品，即整个超级工厂拥有多个产品线。

示例：[dp_abstractfactory.go](design_pattern/dp_abstractfactory.go)

> [!NOTE]
> 有关联的产品是因为这些产品都来自一个超级工厂，一个三星工厂不会同时生产手机和鸡翅。

### 4. 建造者模式

建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。
此模式通常有一个叫做`*Builder`的类负责创建复杂对象的各个部分，它可选的提供一个类 `Setter` 方法来构造对象的每个部分。

**核心**：通过一个 `*Build` 类来逐步构建一个复杂对象。

示例：[dp_builder.go](design_pattern/dp_builder.go)

### 5. 原型模式

原型模式（Prototype Pattern）使你能够复制已有对象， 而又无需使代码依赖它们所属的类。

**核心**：前面的创建型模式都是通过类来创建对象，而原型模式是通过对象来创建对象的。

示例：[dp_prototype.go](design_pattern/dp_prototype.go)

### 6. 单例模式

单例模式（Singleton Pattern）是很常见又很简单的一种设计模式。它只涉及到一个工厂类，该类负责创建对象，
并且无论调用多少次，它都只会创建唯一的一个对象。该类会提供一个访问唯一对象的入口。

**核心**：单例类负责创建自己的对象，同时确保只有单个对象被创建。

示例：[dp_singleton.go](design_pattern/dp_singleton.go)

## 结构型模式

### 7. 适配器模式

适配器模式（Adapter Pattern）将一个类的接口转换成客户希望的另外一个接口。

**核心**：适配器模式在两个不兼容的接口之间构建一座桥梁。

示例：[dp_adapter.go](design_pattern/dp_adapter.go)

> [!TIP]
> 例如：美国电器 110V，中国 220V，就要有一个变压器将 110V 转化为 220V。

### 8. 装饰器模式

装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。
这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。

**核心**：给一个对象无损添加功能。

示例：[dp_decorator.go](design_pattern/dp_decorator.go)

> [!TIP]
> 例如：给对象方法增加日志功能。

### 9. 代理模式

代理模式（Proxy Pattern）为其他对象提供一种代理以控制对这个对象的访问。与装饰器类似，代理模式也会包含一个原对象的引用，
并在访问原对象之前或之后做一些额外的操作。但不同的是，装饰器模式是在原对象的基础之上增强功能，
而代理模式则是控制对原对象的访问。

**使用场景**

- 延迟初始化：延迟初始化一个比较消耗资源的对象，直到它被真正需要的时候。
- 访问控制：代理可仅在客户端凭据满足要求时将请求传递给服务对象。
- 远程处理：代理通过网络传递客户端请求， 负责处理所有与网络相关的复杂细节。
- 记录日志请求。

示例：[dp_proxy.go](design_pattern/dp_proxy.go)

### 10. 外观模式

外观模式（Facade Pattern）为包含许多活动部件的复杂子系统提供一个简单的接口。与直接调用子系统相比，外观提供的功能可能比较有限，
但它却包含了客户端真正关心的功能。

如果你的程序需要与支持多种功能的复杂库整合， 但只需使用其中非常少的功能， 那么使用外观模式会非常方便。

**使用场景**

假如你当前需要在代码中实现一个转换 word 转 pdf 的功能，但调用逻辑可能比较多复杂，且第三方库那么多，有可能你以后会替换现在使用的库。
那么为了避免增加当前上下文的复杂度，以及以后修改此转换逻辑减少对上下文的影响。
我们可以定义一个外观类，外观类中包含所有第三方库的 pdf 调用方法，然后在当前上下文中调用外观类的方法即可。

示例：[dp_facade.go](design_pattern/dp_facade.go)

### 11. 桥接模式

桥接模式（Bridge Pattern）将抽象部分与它的实现部分分离，使它们都可以独立地变化。

**使用场景**

例如当前需要实现一个通过云服务商发送短信的工具类，如果直接在工具类中实现这个功能，那么以后如果需要更换云服务商，
就需要修改工具类，由于工具类方法直接被业务方调用，这样的方式很不稳定。此时就可以使用桥接模式，将发送短信的接口和实现分离出来，
通过桥接方式协作。这样以后更换云服务商时，只需要修改实现部分即可，业务方基本不需要感知。并且接口也可以扩展多个，
也不会影响已有的实现，两边独立扩展。

示例：[dp_bridge.go](design_pattern/dp_bridge.go)

### 12. 组合模式

组合模式（Composite Pattern）将不同对象组合成树形结构,表示"整体-部分"的层次关系。组合模式允许客户端统一地对待
**单个对象和组合对象**。

**使用场景**

例如当前存在一个简单的文件系统，文件系统包含文件夹和文件，文件夹可以包含文件夹和文件，
然后需要实现一种方式能够快速统计文件夹和文件的总数量。

这时候可以使用组合模式，文件夹和文件都可以被抽象成节点，其中文件夹是组合对象，文件是单一对象，
根据它们的关系会形成一个树状结构。然后文件夹节点返回 1+文件数，文件则返回 1，然后通过递归就可以统计出文件夹和文件的总数量。

示例：[dp_composite.go](design_pattern/dp_composite.go)

### 13. 享元模式

享元模式（Flyweight
Pattern）是一种结构型设计模式，它用于减少创建对象的数量，从而**优化内存**的使用。这种模式特别适用于处理大量相似对象的情况，通过共享已经存在的对象来避免创建重复的数据。

享元模式的主要思想是将对象的内部状态和外部状态分离，内部状态是对象可以共享的部分，而外部状态是对象依赖于环境的部分。
享元模式主要包含以下几个角色：

- 享元工厂（Flyweight Factory）：负责创建和管理享元对象。它会检查所需的对象是否已经存在，如果存在，则返回已有对象，否则创建新对象。
- 享元对象（Flyweight）：这些对象可以共享内部状态。它们通常是不可变的，即一旦创建，其内部状态就不会改变。
- 客户端（Client）：客户端使用享元对象。它通过享元工厂获取享元对象，并提供必要的外部状态。

**核心**：此模式包含池化思想，但不同的是，池化的对象可以不同，当客户端所需的独特对象不存在时，可创建新对象。

**举例**：假设正在开发一个文本编辑器，需要在界面上显示大量的字符。如果我们直接为每个字符创建一个对象，那么对于一个包含大量字符的文档来说，
这将消耗大量的内存。为了优化内存使用，我们可以使用享元模式。

示例：[dp_flyweight.go](design_pattern/dp_flyweight.go)

## 行为型模式

### 14. 策略模式

在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。具体来说，它能让你定义一系列算法，并将每种算法分别放入独立的类中，
以使算法的对象能够相互替换。

**核心**：定义多个算法（策略），他们实现相同的接口，可以互相替换。

**举例**：一个导航系统，可以根据不同交通方式制定不同的导航路线。比如步行、自行车、自驾，无论使用哪种交通方式，
导航系统都应该提供相同的功能，即根据起点和终点找到最短路径（在地图上标识出路线图）。

示例：[dp_strategy.go](design_pattern/dp_strategy.go)

### 15. 模板方法模式

模板方法模式（Template Method Pattern）是一种行为设计模式，它在父类中定义了一个算法的框架（不可修改），
允许子类在不修改结构的情况下重写算法的特定步骤。

这种模式是通过定义一个抽象类来实现的，其中包含执行算法所需的一系列步骤（模板方法），并将一些步骤的具体实现留给子类来提供。
该模式包含**一个抽象类**和**一个或多个具体子类**。

**核心**：模板方法模式的目的是提供一种代码复用的方式，同时保持算法的结构不变。它允许子类在不修改整体步骤的情况下，重新定义算法的某些步骤，从而具有很高的灵活性。

**举例**：假设我们有一个咖啡制作机，它可以制作不同类型的咖啡，如浓缩咖啡（Espresso）、拿铁咖啡（Latte）等。尽管这些咖啡的制作过程有所不同，但它们的基本步骤是相同的，
比如磨豆、烧水、冲泡等。

示例：[dp_templatemethod.go](design_pattern/dp_templatemethod.go)

### 16. 观察者模式

观察者模式（Observer Pattern）是一种行为设计模式，它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象（的变化）。
这种模式主要用于实现分布式系统中的事件处理机制，或者在任何需要消息传递和事件驱动的场景中。

**目的**：观察者模式的目的是实现对象间的解耦，让多个观察者对象同时监听某一个主题对象，当主题对象发生变化时，所有的观察者都会得到通知。
这种模式使得主题对象与观察者对象之间的依赖关系减弱，提高了系统的可扩展性和可维护性。

观察者模式主要包括以下几个角色：

- 主题（Subject）：接口，定义了注册、注销和通知观察者的方法。
- 具体主题（Concrete Subject）：实现了主题接口的具体类，它包含具体业务逻辑，并在状态发生变化时通知所有注册的观察者。
- 观察者（Observer）：接口，定义了观察者需要实现的方法，通常是一个更新方法（update），用于接收状态变化的通知。
- 具体观察者（Concrete Observer）：实现了观察者接口的具体类，它们注册到主题上，以便在主题状态发生变化时接收更新。

**举例**：假设我们有一个天气预报服务，它可以提供当前的天气信息，并且有多个子系统需要根据天气信息做出相应的操作，比如更新网页显示、发送天气预警短信等。
我们可以使用观察者模式来设计这个系统。那么这里的具体主题是天气服务，具体观察者是各个子系统（如WebGUI和AlertSystem）。

示例：[dp_observer.go](design_pattern/dp_observer.go)

### 17. 迭代器模式

迭代器模式（Iterator Pattern）提供了一种方法来顺序访问集合对象中的一系列数据，而不需要暴露集合内部结构。
此模式在如Java、Python等语言中经常使用，它们通常提供将集合类型转换为迭代器的内置方法。

此模式的优势很多，所以它被广泛应用于各种编程语言中。下面是一些常见优点：

- 提供统一访问接口，使得客户端可以遍历集合对象而无需了解其内部结构（即存储方式）。
- 解耦聚合对象与客户端，聚合对象内部结构可以自由变化，而不会影响客户端对它的访问。
- 支持多种遍历方式：例如正向遍历、逆向遍历，条件遍历。
- 优化性能：使用迭代器模式无需一次性加载整个集合，而是逐个访问元素，大大减少内存消耗。

迭代器模式通常包含以下角色：

- 集合对象：是一个包含多个元素的集合对象（如数组、哈希Map等），负责提供创建迭代器对象的方法。
- 迭代器：是一个接口，包含用于遍历集合元素的方法，如 `next()`。
- 具体迭代器：实现了迭代器接口的具体类，它维护一个指向当前元素的游标，并提供遍历集合的逻辑。

**举例**：假如由一个较大的图书集合，我们需要遍历这个集合，并输出每本书的名称。

示例：[dp_iterator.go](design_pattern/dp_iterator.go)

### 18. 责任链模式

责任链模式（Chain of Responsibility Pattern）是一种行为设计模式，允许你将请求沿着处理者链进行发送。收到请求后，每个处理者均可对请求进行处理，
还可决定是否将其传递给链上的下个处理者。

责任链模式包含以下角色：

- 抽象处理者：定义了处理请求的接口，声明了用于设置和获取下一个处理者的引用的方法（通常为 setNext 和 getNext）。
- 具体处理者：实现了抽象处理者接口的具体类，它们处理请求，并且可以决定是处理该请求还是将请求传递给链中的下一个处理者。
- 客户端：创建由处理者形成的责任链。发送请求给责任链，但不需要知道请求会被哪个具体处理者处理。

**核心**：定义多个处理者，串行处理请求，每个处理者可以决定是否继续传递请求。

**场景**：比如Web框架中的请求处理中间件，可以对请求进行鉴权、日志记录、风险检测等操作。

示例：[dp_chainofresponsibility.go](design_pattern/dp_chainofresponsibility.go)

### 19. 命令模式

命令模式（Command Pattern）将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求进行排队或者记录请求日志，
可以提供命令的撤销和恢复功能。

**理解**：有时候需要向某些对象发送请求，但是并不想知道请求的接收者是谁，也不想知道被请求的操作的具体执行步骤，只希望请求被执行。
这种模式实现了请求发送者和请求接收者（也是最终处理者）之间的解耦。

主要包含以下角色：

- Command：命令接口，声明执行命令的抽象方法，通常包含一个`execute()`方法。
- ConcreteCommand：实现了命令接口的具体类，它包含接收者（Receiver）的引用，并在`execute`方法中调用接收者的方法来执行与请求相关的操作。
- Receiver：命令接收者，也是最终处理者。
- Invoker：命令调用者，负责调用命令（传递到Receiver）。
- Client：创建命令对象并设定其接收者。

流程：客户端创建命令对象，并设定命令接收者，然后将命令对象传递给调用者（Invoker），最终调用者将命令传递给接收者（Receiver）执行。

**举例**：假设有一个遥控器，它包含多个按钮，每个按钮都对应一个命令。当按下按钮时，遥控器会发送命令给电视机执行。

示例：[dp_command.go](design_pattern/dp_command.go)

### 20. 备忘录模式

备忘录模式（Memento Pattern）允许在不暴露对象实现细节的情况下保存和恢复对象之前的状态。

假设A对象不是我创建的，但我想要保存它的状态，以便以后可以恢复它。此时如果A自身没有提供快照方法的话，那就没有一种好的办法能做到这一点。
因为A对象可能存在外部无法访问的私有变量。所以最好的办法是A对象自身提供一个 `makeSnapshot和restore` 的方法，
以允许从外部调用来生成它的快照和从快照恢复。

备忘录模式主要包括以下几个角色：

- 发起人（Originator）：负责创建一个备忘录，用以记录当前对象的状态信息，并可以恢复到该状态。发起人通常拥有创建和恢复备忘录的方法。
- 备忘录（Memento）：一个包含发起人状态信息的对象。备忘录通常有两个接口，一个提供给发起人，允许其保存状态信息；另一个提供给负责人（Caretaker），允许其存储备忘录。
- 负责人（Caretaker）：负责管理备忘录，它通常只负责保存和提供备忘录，而不关心备忘录的具体内容。负责人可以有多个备忘录，以便在不同的时间点保存和恢复状态。

**举例**：在视频游戏中，玩家可能希望在特定关卡或进度点保存游戏状态，以便之后可以从该点继续游戏。备忘录模式允许游戏保存当前的游戏状态，包括玩家的位置、生命值、收集的物品等。

示例：[dp_memento.go](design_pattern/dp_memento.go)

### 21. 状态模式

状态模式（State Pattern）允许对象在内部状态改变时改变它的行为，对象看起来似乎修改了它的类。

**理解**：可以应用状态模式的对象通常拥有几种状态可以互相转换，并且每种状态都会影响对象的行为。如果不应有设计模式，
那可能需要许多条件语句来是实现状态变更时的行为逻辑，类似一个状态机。潜在的问题是，随着项目发展，状态机可能会变得非常复杂而难以维护。
状态模式建议将所有状态相关的代码抽取到单独的状态接口中，每个状态类都负责处理与该状态相关的行为逻辑。

状态模式包含以下角色：

- 上下文（Context）：拥有状态（State）的原始对象，并负责切换状态。
- 状态（State）：是一个抽象类或接口，定义了一个接口以封装与Context的一个特定状态相关的行为。
- 具体状态（Concrete State）：它实现了State接口，并定义了与Context的某一个具体状态相关的行为。

**目的**：将与特定状态相关的行为局部化，并且将不同状态的行为分割开来，将它们封装在独立的对象中。这样，当状态变化时，可以避免使用大量的条件语句，
并且使得添加新的状态变得容易。

**举例**：当涉及到订单状态时，状态模式可以很好地管理订单的各种状态变化，比如新建、已确认、已发货、已完成等。

示例：[dp_state.go](design_pattern/dp_state.go)

### 22. 访问者模式

访问者模式（Visitor Pattern）是一种行为型设计模式，它允许在不修改对象结构的情况下，添加新的操作。访问者模式通过将算法移动到对象结构之外，
并将算法作为一个访问者对象传入对象结构，从而实现对对象结构中的元素执行操作。

访问者模式包含以下角色：

- 元素（Element）：定义了一个 `Accept` 方法，它接受一个访问者对象。
- 具体元素（Concrete Element）：实现了元素角色的 `Accept` 方法，这个 `Accept` 方法将访问者对象传入具体元素对象。
- 访问者（Visitor）：定义了对每一个元素类 `Visit` 操作的接口。它可以访问元素的内部数据。
- 具体访问者（Concrete Visitor）：实现了对各个具体元素类的 `Visit` 操作。
- 对象结构（Object Structure）：通常是一个包含元素对象的集合，它能够接受访问者对象，并依次对每个元素调用 `Accept` 方法。

**目的**：访问者模式的目的是使对象结构与操作算法解耦，提供一种灵活的、可扩展的算法设计。当需要对一个对象结构添加新的操作时，不需要修改对象结构中的类，
只需要添加一个新的访问者类即可。

**核心**：访问者模式的核心思想是将操作逻辑与对象结构分离。

**举例**：假设有一个电子商务网站，需要对订单中的不同商品进行不同的处理操作，例如计算总价、计算折扣等。我们可以使用访问者模式来设计这个系统。

示例：[dp_visitor.go](design_pattern/dp_visitor.go)

### 23. 中介者模式

中介者模式（Mediator Pattern）是用来降低多个对象或类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，
使代码易于维护。它定义了一个中介对象，用以封装一系列对象之间的交互。中介者使各对象不需要显示地相互引用，从而使耦合度降低，而且可以独立地改变它们之间的交互。

**理解**：在一个系统中，A/B/C需要和E/F/G产生合作，如果直接在A/B/C的代码中调用E/F/G的代码，那么A/B/C和E/F/G之间就会产生强耦合，且许多代码都是重复的。
此时可以新增一个中介者类，A/B/C和E/F/G都不需要和对方直接交互，而是通过中介者类进行交互。

中介者模式包含以下角色：

- 中介者（Mediator）：定义了同事对象如何与其进行通信的接口。
- 具体中介者（Concrete Mediator）：实现了中介者接口的具体类，它需要协调各个同事对象之间的交互，通常维护了所有同事对象的引用。。
- 同事对象（Colleague）：各同事对象只知道中介者，并且使用中介者对象来与其他同事对象通信。
- 具体同事类（Concrete Colleague）：实现了同事对象接口的具体类，它们通过中介者来发送消息，并且处理接收到的消息。

**核心**：中介者模式的核心思想是将对象之间的通信封装到中介者对象中，从而降低对象之间的耦合度，同时可以集中控制对象之间的通信，使得系统的通信逻辑更加清晰。

**举例**： 假设有一个聊天室系统，用户可以发送消息，其他用户可以接收到这些消息。我们可以使用中介者模式来设计这个系统。

示例：[dp_mediator.go](design_pattern/dp_mediator.go)

### 24. 解释器模式

解释器模式（Interpreter Pattern）定义了一个语言的文法，并建立一个解释器来解释该语言中的句子。在这里，“语言”指的是使用规定格式和语法的代码。
解释器模式通常用于解释特定类型的问题，可利用场景比较少。

在解释器模式中，通常会有以下几个角色：

- 抽象表达式（Abstract Expression）：定义了一个解释器的接口，其中包含了一个 `interpret()` 方法，用于解释语言中的表达式。
- 终结符表达式（Terminal Expression）：实现了抽象表达式接口，表示语言中的终结符，即不可再拆分的最小单元，例如 `3+2`
  中的`3`，`+`，`2`都是终结符。
- 非终结符表达式（Non-terminal
  Expression）：也是实现了抽象表达式接口，表示语言中的非终结符，通常由终结符和其他非终结符组成，可以包含其他表达式。例如 `3*(2+3)`
  中的`(2+3)`。
- 上下文环境（Context）：根据情况可有可无。包含了解释器需要的全局信息或状态，供解释器进行解释。
- 客户端（Client）：创建并配置解释器，然后传入要解释的表达式，触发解释过程。

**理解**：解释器模式可能是最难理解的设计模式之一，因为它涉及编译原理。此处的**表达式**、**语法树**、**（非）终结符**
等概念都来自编译原理。

- 词法和语法（Lexical&Syntax）：定义了语言的规则和结构的一组规则集合；
- 文法（Grammar）：是一种形式化的规则系统，用于描述语言的结构和构成，是编译器中**语法分析的基础**。
- 终结符（TerminalChar）：文法中的最小单位，不可再拆分。常见的有数字（0-9）、加号（+）、减号（-）、乘号（*）、除号（/）、左括号（(）、
  右括号（)）；
- 非终结符（Non-TerminalChar）：由终结符和其他非终结符组成的，可以通过解释器进一步解析和分解。例如表达式（Expr）、项（Term）、因子（Factor）；
- 表达式（Expression）：又叫句子，是根据文法定义的语言的组成部分，表示特定含义的符号串。表达式可以是终结符或非终结符；
- 语法树（SyntaxTree）：由表达式组成的树状结构，表示了语言的结构和语法规则。解释器会根据输入的表达式构建语法树，并通过遍历语法树来执行解释和计算。
- 解析器（Parser）：根据文法定义的规则，将输入的表达式解析成语法树，这是一个**难点**。

适用于以下场景：

- 当有一个语言需要解释执行，并且该语言的语法较为简单或者对应的语法规则较少时。
- 当问题重复出现，且可以用一种简单的语言来进行表达时。
- 当一个语言需要解释执行，并且语言中的句子可以表示为一个抽象语法树的时候，如 XML 文档解释。

**优点**： 1、可扩展性比较好，灵活。 2、增加了新的解释表达式的方式。 3、易于实现简单文法。
**缺点**： 1、可利用场景比较少。 2、对于复杂的文法比较难维护。 3、解释器模式会引起类膨胀。 4、解释器模式采用递归调用方法。

**举例**：使用解释器模式来解释`3 * (5 + 12)-1`。完成这个任务需要以下步骤：

- 定义词法和语法规则。
  - 词法：允许单个和多个字符构成的数字，如数字3,5,12,1都是终结符。
  - 加减法（+-）和乘法（*）是二元运算符，它们是非终结符，因为它们可以分解为两个操作数。
  - 括号用于指定运算的优先级。
- 构建语法树（AST），由多个不同类型的节点构成，此例中具有如下几个节点类型：
  - NumberExpression 表示一个数字。
  - AddExpression、MinusExpression、MultiplyExpression 都表示一个二元运算，即加减法和乘法。
  - ParenthesesExpression 表示一个带有括号的子表达式。
- 解析表达式：使用一个递归下降解析器，根据语法规则解析语法树，并计算出结果。

示例：[dp_interpreter.go](design_pattern/dp_interpreter.go)

## REFERENCE

- https://refactoringguru.cn/design-patterns
- https://zhuanlan.zhihu.com/p/128145128
- https://github.com/senghoo/golang-design-pattern