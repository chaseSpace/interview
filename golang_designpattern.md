# 设计模式篇

在软件工程中，设计模式（design pattern）是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案，最初从建筑行业引入。

24 种设计模式有三种分类：创建型模式、结构型模式、行为型模式。

- 创建型模式：对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离。
    - （6 种）简单工厂模式、工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式
- 结构型模式：关注于对象的组成以及对象之间的依赖关系，描述如何将类或者对象结合在一起形成更大的结构。
    - （7 种）适配器模式、装饰者模式、代理模式、外观模式、桥接模式、组合模式、享元模式
- 行为型模式：关注于对象的行为问题，是对在不同的对象之间划分责任和算法的抽象化；不仅仅关注类和对象的结构，而且重点关注它们之间的相互作用。
    - （11 种）策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式

## 创建型模式

### 1. 简单工厂模式

简单工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。

**核心**：一个工厂类生产一类产品，这类产品都实现了同一个产品接口。

Go 语言没有 Java/Python 中的构造函数概念（也就没有工厂类概念），一般都是定义 `NewXXX` 函数来初始化相关产品或类。
可以将 `NewXXX` 叫做工厂函数。

示例：[dp_simplefactory.go](design_pattern/dp_simplefactory.go)

### 2. 工厂方法模式

工厂方法模式（Factory Method Pattern）是简单工厂模式的进一步抽象。

**核心**：一个工厂接口+多个工厂类，每个工厂类负责生产一类产品。

示例：[dp_factorymethod.go](design_pattern/dp_factorymethod.go)

> [!NOTE]
> 工厂方法模式比简单工厂模式多了一个工厂接口。

### 3. 抽象工厂模式

在简单工厂和工厂方法模式中，我们都只需生产一类产品，比如只生产（各种品牌的）电池。
但有时候，我们需要生产多类（有关联的）产品，它们属于不同产品线，比如需要生产（各种品牌的）电池和屏幕。
此时，抽象工厂模式就可以派上用场了。

在抽象工厂模式中，首先有一个超级工厂接口，它可以生产多个产品线的工厂类，然后产出的这些工厂类再生产出对应的产品。

例如有一个生产电池和屏幕的超级工厂接口，具体的超级工厂可以是三星超级工厂、小米超级工厂等。
一个三星超级工厂拥有生产三星牌电池和屏幕的产品线，一个小米超级工厂拥有生产小米牌电池和屏幕的产品线。

**核心**： 一个超级工厂接口+多个子工厂类，每个子工厂类生产一类产品，即整个超级工厂拥有多个产品线。

示例：[dp_abstractfactory.go](design_pattern/dp_abstractfactory.go)

> [!NOTE]
> 有关联的产品是因为这些产品都来自一个超级工厂，一个三星工厂不会同时生产手机和鸡翅。

### 4. 建造者模式

建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。
此模式通常有一个叫做`*Builder`的类负责创建复杂对象的各个部分，它可选的提供一个类 `Setter` 方法来构造对象的每个部分。

**核心**：通过一个 `*Build` 类来逐步构建一个复杂对象。

示例：[dp_builder.go](design_pattern/dp_builder.go)

### 5. 原型模式

原型模式（Prototype Pattern）使你能够复制已有对象， 而又无需使代码依赖它们所属的类。

**核心**：前面的创建型模式都是通过类来创建对象，而原型模式是通过对象来创建对象的。

示例：[dp_prototype.go](design_pattern/dp_prototype.go)

### 6. 单例模式

单例模式（Singleton Pattern）是很常见又很简单的一种设计模式。它只涉及到一个工厂类，该类负责创建对象，
并且无论调用多少次，它都只会创建唯一的一个对象。该类会提供一个访问唯一对象的入口。

**核心**：单例类负责创建自己的对象，同时确保只有单个对象被创建。

示例：[dp_singleton.go](design_pattern/dp_singleton.go)

## 结构型模式

### 7. 适配器模式

适配器模式（Adapter Pattern）将一个类的接口转换成客户希望的另外一个接口。

**核心**：适配器模式在两个不兼容的接口之间构建一座桥梁。

示例：[dp_adapter.go](design_pattern/dp_adapter.go)

> [!TIP]
> 例如：美国电器 110V，中国 220V，就要有一个变压器将 110V 转化为 220V。

### 8. 装饰器模式

装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。
这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。

**核心**：给一个对象无损添加功能。

示例：[dp_decorator.go](design_pattern/dp_decorator.go)

> [!TIP]
> 例如：给对象方法增加日志功能。

### 9. 代理模式

代理模式（Proxy Pattern）为其他对象提供一种代理以控制对这个对象的访问。与装饰器类似，代理模式也会包含一个原对象的引用，
并在访问原对象之前或之后做一些额外的操作。但不同的是，装饰器模式是在原对象的基础之上增强功能，
而代理模式则是控制对原对象的访问。

**使用场景**

- 延迟初始化：延迟初始化一个比较消耗资源的对象，直到它被真正需要的时候。
- 访问控制：代理可仅在客户端凭据满足要求时将请求传递给服务对象。
- 远程处理：代理通过网络传递客户端请求， 负责处理所有与网络相关的复杂细节。
- 记录日志请求。

示例：[dp_proxy.go](design_pattern/dp_proxy.go)

### 10. 外观模式

外观模式（Facade Pattern）为包含许多活动部件的复杂子系统提供一个简单的接口。与直接调用子系统相比，外观提供的功能可能比较有限，
但它却包含了客户端真正关心的功能。

如果你的程序需要与包含几十种功能的复杂库整合， 但只需使用其中非常少的功能， 那么使用外观模式会非常方便，

**使用场景**

假如你当前需要在代码中实现一个转换 word 转 pdf 的功能，但第三方库那么多，有可能你以后会替换现在使用的库。
那么为了避免对当前上下文的修改，你可以定义一个外观类，外观类中包含所有第三方库的 pdf 调用方法，然后在当前上下文中调用外观类的方法即可。

示例：[dp_facade.go](design_pattern/dp_facade.go)

## REFERENCE

- https://refactoringguru.cn/design-patterns
- https://zhuanlan.zhihu.com/p/128145128
- https://github.com/senghoo/golang-design-pattern