# 设计模式篇

在软件工程中，设计模式（design pattern）是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案，最初从建筑行业引入。

24 种设计模式有三种分类：创建型模式、结构型模式、行为型模式。

- 创建型模式：对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离。
    - （6 种）简单工厂模式、工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式
- 结构型模式：关注于对象的组成以及对象之间的依赖关系，描述如何将类或者对象结合在一起形成更大的结构。
    - （7 种）适配器模式、装饰者模式、代理模式、外观模式、桥接模式、组合模式、享元模式
- 行为型模式：关注于对象的行为问题，是对在不同的对象之间划分责任和算法的抽象化；不仅仅关注类和对象的结构，而且重点关注它们之间的相互作用。
    - （11 种）策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式

## 创建型模式

### 1. 简单工厂模式

简单工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。

**核心**：一个工厂类生产一类产品，这类产品都实现了同一个产品接口。

Go 语言没有 Java/Python 中的构造函数概念（也就没有工厂类概念），一般都是定义 `NewXXX` 函数来初始化相关产品或类。
可以将 `NewXXX` 叫做工厂函数。

示例：[dp_simplefactory.go](design_pattern/dp_simplefactory.go)

### 2. 工厂方法模式

工厂方法模式（Factory Method Pattern）是简单工厂模式的进一步抽象。

**核心**：一个工厂接口+多个工厂类，每个工厂类负责生产一类产品。

示例：[dp_factorymethod.go](design_pattern/dp_factorymethod.go)

> [!NOTE]
> 工厂方法模式比简单工厂模式多了一个工厂接口。

### 3. 抽象工厂模式

在简单工厂和工厂方法模式中，我们都只需生产一类产品，比如只生产（各种品牌的）电池。
但有时候，我们需要生产多类（有关联的）产品，它们属于不同产品线，比如需要生产（各种品牌的）电池和屏幕。
此时，抽象工厂模式就可以派上用场了。

在抽象工厂模式中，首先有一个超级工厂接口，它可以生产多个产品线的工厂类，然后产出的这些工厂类再生产出对应的产品。

例如有一个生产电池和屏幕的超级工厂接口，具体的超级工厂可以是三星超级工厂、小米超级工厂等。
一个三星超级工厂拥有生产三星牌电池和屏幕的产品线，一个小米超级工厂拥有生产小米牌电池和屏幕的产品线。

**核心**： 一个超级工厂接口+多个子工厂类，每个子工厂类生产一类产品，即整个超级工厂拥有多个产品线。

示例：[dp_abstractfactory.go](design_pattern/dp_abstractfactory.go)

> [!NOTE]
> 有关联的产品是因为这些产品都来自一个超级工厂，一个三星工厂不会同时生产手机和鸡翅。

### 4. 建造者模式

建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。
此模式通常有一个叫做`*Builder`的类负责创建复杂对象的各个部分，它可选的提供一个类 `Setter` 方法来构造对象的每个部分。

**核心**：通过一个 `*Build` 类来逐步构建一个复杂对象。

示例：[dp_builder.go](design_pattern/dp_builder.go)

### 5. 原型模式

原型模式（Prototype Pattern）使你能够复制已有对象， 而又无需使代码依赖它们所属的类。

**核心**：前面的创建型模式都是通过类来创建对象，而原型模式是通过对象来创建对象的。

示例：[dp_prototype.go](design_pattern/dp_prototype.go)

### 6. 单例模式

单例模式（Singleton Pattern）是很常见又很简单的一种设计模式。它只涉及到一个工厂类，该类负责创建对象，
并且无论调用多少次，它都只会创建唯一的一个对象。该类会提供一个访问唯一对象的入口。

**核心**：单例类负责创建自己的对象，同时确保只有单个对象被创建。

示例：[dp_singleton.go](design_pattern/dp_singleton.go)

## 结构型模式

### 7. 适配器模式

适配器模式（Adapter Pattern）将一个类的接口转换成客户希望的另外一个接口。

**核心**：适配器模式在两个不兼容的接口之间构建一座桥梁。

示例：[dp_adapter.go](design_pattern/dp_adapter.go)

> [!TIP]
> 例如：美国电器 110V，中国 220V，就要有一个变压器将 110V 转化为 220V。

### 8. 装饰器模式

装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。
这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。

**核心**：给一个对象无损添加功能。

示例：[dp_decorator.go](design_pattern/dp_decorator.go)

> [!TIP]
> 例如：给对象方法增加日志功能。

### 9. 代理模式

代理模式（Proxy Pattern）为其他对象提供一种代理以控制对这个对象的访问。与装饰器类似，代理模式也会包含一个原对象的引用，
并在访问原对象之前或之后做一些额外的操作。但不同的是，装饰器模式是在原对象的基础之上增强功能，
而代理模式则是控制对原对象的访问。

**使用场景**

- 延迟初始化：延迟初始化一个比较消耗资源的对象，直到它被真正需要的时候。
- 访问控制：代理可仅在客户端凭据满足要求时将请求传递给服务对象。
- 远程处理：代理通过网络传递客户端请求， 负责处理所有与网络相关的复杂细节。
- 记录日志请求。

示例：[dp_proxy.go](design_pattern/dp_proxy.go)

### 10. 外观模式

外观模式（Facade Pattern）为包含许多活动部件的复杂子系统提供一个简单的接口。与直接调用子系统相比，外观提供的功能可能比较有限，
但它却包含了客户端真正关心的功能。

如果你的程序需要与支持多种功能的复杂库整合， 但只需使用其中非常少的功能， 那么使用外观模式会非常方便。

**使用场景**

假如你当前需要在代码中实现一个转换 word 转 pdf 的功能，但调用逻辑可能比较多复杂，且第三方库那么多，有可能你以后会替换现在使用的库。
那么为了避免增加当前上下文的复杂度，以及以后修改此转换逻辑减少对上下文的影响。
我们可以定义一个外观类，外观类中包含所有第三方库的 pdf 调用方法，然后在当前上下文中调用外观类的方法即可。

示例：[dp_facade.go](design_pattern/dp_facade.go)

### 11. 桥接模式

桥接模式（Bridge Pattern）将抽象部分与它的实现部分分离，使它们都可以独立地变化。

**使用场景**

例如当前需要实现一个通过云服务商发送短信的工具类，如果直接在工具类中实现这个功能，那么以后如果需要更换云服务商，
就需要修改工具类，由于工具类方法直接被业务方调用，这样的方式很不稳定。此时就可以使用桥接模式，将发送短信的接口和实现分离出来，
通过桥接方式协作。这样以后更换云服务商时，只需要修改实现部分即可，业务方基本不需要感知。并且接口也可以扩展多个，
也不会影响已有的实现，两边独立扩展。

示例：[dp_bridge.go](design_pattern/dp_bridge.go)

### 12. 组合模式

组合模式（Composite Pattern）将不同对象组合成树形结构,表示"整体-部分"的层次关系。组合模式允许客户端统一地对待
**单个对象和组合对象**。

**使用场景**

例如当前存在一个简单的文件系统，文件系统包含文件夹和文件，文件夹可以包含文件夹和文件，
然后需要实现一种方式能够快速统计文件夹和文件的总数量。

这时候可以使用组合模式，文件夹和文件都可以被抽象成节点，其中文件夹是组合对象，文件是单一对象，
根据它们的关系会形成一个树状结构。然后文件夹节点返回 1+文件数，文件则返回 1，然后通过递归就可以统计出文件夹和文件的总数量。

示例：[dp_composite.go](design_pattern/dp_composite.go)

### 13. 享元模式

享元模式（Flyweight
Pattern）是一种结构型设计模式，它用于减少创建对象的数量，从而**优化内存**的使用。这种模式特别适用于处理大量相似对象的情况，通过共享已经存在的对象来避免创建重复的数据。

享元模式的主要思想是将对象的内部状态和外部状态分离，内部状态是对象可以共享的部分，而外部状态是对象依赖于环境的部分。
享元模式主要包含以下几个角色：

- 享元工厂（Flyweight Factory）：负责创建和管理享元对象。它会检查所需的对象是否已经存在，如果存在，则返回已有对象，否则创建新对象。
- 享元对象（Flyweight）：这些对象可以共享内部状态。它们通常是不可变的，即一旦创建，其内部状态就不会改变。
- 客户端（Client）：客户端使用享元对象。它通过享元工厂获取享元对象，并提供必要的外部状态。

**核心**：此模式包含池化思想，但不同的是，池化的对象可以不同，当客户端所需的独特对象不存在时，可创建新对象。

**举例**：假设正在开发一个文本编辑器，需要在界面上显示大量的字符。如果我们直接为每个字符创建一个对象，那么对于一个包含大量字符的文档来说，
这将消耗大量的内存。为了优化内存使用，我们可以使用享元模式。

示例：[dp_flyweight.go](design_pattern/dp_flyweight.go)

## 行为型模式

### 14. 策略模式

在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。具体来说，它能让你定义一系列算法，并将每种算法分别放入独立的类中，
以使算法的对象能够相互替换。

**核心**：定义多个算法（策略），他们实现相同的接口，可以互相替换。

**举例**：一个导航系统，可以根据不同交通方式制定不同的导航路线。比如步行、自行车、自驾，无论使用哪种交通方式，
导航系统都应该提供相同的功能，即根据起点和终点找到最短路径（在地图上标识出路线图）。

示例：[dp_strategy.go](design_pattern/dp_strategy.go)

### 15. 模板方法模式

模板方法模式（Template Method Pattern）是一种行为设计模式，它在父类中定义了一个算法的框架（不可修改），
允许子类在不修改结构的情况下重写算法的特定步骤。

这种模式是通过定义一个抽象类来实现的，其中包含执行算法所需的一系列步骤（模板方法），并将一些步骤的具体实现留给子类来提供。
该模式包含**一个抽象类**和**一个或多个具体子类**。

**核心**：模板方法模式的目的是提供一种代码复用的方式，同时保持算法的结构不变。它允许子类在不修改整体步骤的情况下，重新定义算法的某些步骤，从而具有很高的灵活性。

**举例**：假设我们有一个咖啡制作机，它可以制作不同类型的咖啡，如浓缩咖啡（Espresso）、拿铁咖啡（Latte）等。尽管这些咖啡的制作过程有所不同，但它们的基本步骤是相同的，
比如磨豆、烧水、冲泡等。

示例：[dp_templatemethod.go](design_pattern/dp_templatemethod.go)

### 16. 观察者模式

观察者模式（Observer Pattern）是一种行为设计模式，它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象（的变化）。

这种模式主要用于实现分布式系统中的事件处理机制，或者在任何需要消息传递和事件驱动的场景中。

**目的**：观察者模式的目的是实现对象间的解耦，让多个观察者对象同时监听某一个主题对象，当主题对象发生变化时，所有的观察者都会得到通知。
这种模式使得主题对象与观察者对象之间的依赖关系减弱，提高了系统的可扩展性和可维护性。

观察者模式主要包括以下几个角色：

- 主题（Subject）：也称为可观察对象，它是观察者模式的核心。主题维护一个观察者列表，并负责通知所有观察者状态的变化。
- 观察者（Observer）：它是一个接口，定义了观察者需要实现的方法，通常是一个更新方法（update），用于接收状态变化的通知。
- 具体观察者（Concrete Observer）：实现了观察者接口的具体类，它们注册到主题上，以便在主题状态发生变化时接收更新。
- 具体主题（Concrete Subject）：实现了主题接口的具体类，它包含业务逻辑，并在状态发生变化时通知所有注册的观察者。

**举例**：假设我们有一个天气预报服务，它可以提供当前的天气信息，并且有多个子系统需要根据天气信息做出相应的操作，比如更新网页显示、发送天气预警短信等。
我们可以使用观察者模式来设计这个系统。那么这里的具体主题是天气服务，具体观察者是各个子系统（如WebGUI和AlertSystem）。

示例：[dp_observer.go](design_pattern/dp_observer.go)

### 17. 迭代器模式

迭代器模式（Iterator Pattern）提供了一种方法来顺序访问集合对象中的一系列数据，而不需要暴露集合内部结构。
此模式在如Java、Python等语言中经常使用，它们通常提供将集合类型转换为迭代器的内置方法。

此模式的优势很多，所以它被广泛应用于各种编程语言中。下面是一些常见优点：

- 提供统一访问接口，使得客户端可以遍历集合对象而无需了解其内部结构（即存储方式）。
- 解耦聚合对象与客户端，聚合对象内部结构可以自由变化，而不会影响客户端对它的访问。
- 支持多种遍历方式：例如正向遍历、逆向遍历，条件遍历。
- 优化性能：使用迭代器模式无需一次性加载整个集合，而是逐个访问元素，大大减少内存消耗。

迭代器模式通常包含以下角色：

- 集合对象：是一个包含多个元素的集合对象（如数组、哈希Map等），负责提供创建迭代器对象的方法。
- 迭代器：是一个接口，包含用于遍历集合元素的方法，如 `next()`。
- 具体迭代器：实现了迭代器接口的具体类，它维护一个指向当前元素的游标，并提供遍历集合的逻辑。

**举例**：假如由一个较大的图书集合，我们需要遍历这个集合，并输出每本书的名称。

示例：[dp_iterator.go](design_pattern/dp_iterator.go)

### 18. 责任链模式

责任链模式（Chain of Responsibility Pattern）是一种行为设计模式，允许你将请求沿着处理者链进行发送。收到请求后，每个处理者均可对请求进行处理，
还可决定是否将其传递给链上的下个处理者。

责任链模式包含以下角色：

- 抽象处理者：定义了处理请求的接口，声明了用于设置和获取下一个处理者的引用的方法（通常为 setNext 和 getNext）。
- 具体处理者：实现了抽象处理者接口的具体类，它们处理请求，并且可以决定是处理该请求还是将请求传递给链中的下一个处理者。
- 客户端：创建由处理者形成的责任链。发送请求给责任链，但不需要知道请求会被哪个具体处理者处理。

**核心**：定义多个处理者，串行处理请求，每个处理者可以决定是否继续传递请求。

**场景**：比如Web框架中的请求处理中间件，可以对请求进行鉴权、日志记录、风险检测等操作。

示例：[dp_chainofresponsibility.go](design_pattern/dp_chainofresponsibility.go)

### 19. 命令模式

命令模式（Command Pattern）将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求进行排队或者记录请求日志，
可以提供命令的撤销和恢复功能。

**理解**：有时候需要向某些对象发送请求，但是并不想知道请求的接收者是谁，也不想知道被请求的操作的具体执行步骤，只希望请求被执行。
这种模式实现了请求发送者和请求接收者（也是最终处理者）之间的解耦。

主要包含以下角色：

- Command：命令接口，声明执行命令的抽象方法，通常包含一个`execute()`方法。
- ConcreteCommand：实现了命令接口的具体类，它包含接收者（Receiver）的引用，并在`execute`方法中调用接收者的方法来执行与请求相关的操作。
- Receiver：命令接收者，也是最终处理者。
- Invoker：命令调用者，负责调用命令（传递到Receiver）。
- Client：创建命令对象并设定其接收者。

流程：客户端创建命令对象，并设定命令接收者，然后将命令对象传递给调用者（Invoker），最终调用者将命令传递给接收者（Receiver）执行。

**举例**：假设有一个遥控器，它包含多个按钮，每个按钮都对应一个命令。当按下按钮时，遥控器会发送命令给电视机执行。

示例：[dp_command.go](design_pattern/dp_command.go)

### 20. 备忘录模式

备忘录模式（Memento Pattern）允许在不暴露对象实现细节的情况下保存和恢复对象之前的状态。

假设A对象不是我创建的，但我想要保存它的状态，以便以后可以恢复它。此时如果A自身没有提供快照方法的话，那就没有一种好的办法能做到这一点。
因为A对象可能存在外部无法访问的私有变量。所以最好的办法是A对象自身提供一个 `makeSnapshot和restore` 的方法，
以允许从外部调用来生成它的快照和从快照恢复。

备忘录模式主要包括以下几个角色：

- 发起人（Originator）：负责创建一个备忘录，用以记录当前对象的状态信息，并可以恢复到该状态。发起人通常拥有创建和恢复备忘录的方法。
- 备忘录（Memento）：一个包含发起人状态信息的对象。备忘录通常有两个接口，一个提供给发起人，允许其保存状态信息；另一个提供给负责人（Caretaker），允许其存储备忘录。
- 负责人（Caretaker）：负责管理备忘录，它通常只负责保存和提供备忘录，而不关心备忘录的具体内容。负责人可以有多个备忘录，以便在不同的时间点保存和恢复状态。

**举例**：在视频游戏中，玩家可能希望在特定关卡或进度点保存游戏状态，以便之后可以从该点继续游戏。备忘录模式允许游戏保存当前的游戏状态，包括玩家的位置、生命值、收集的物品等。

示例：[dp_memento.go](design_pattern/dp_memento.go)

## REFERENCE

- https://refactoringguru.cn/design-patterns
- https://zhuanlan.zhihu.com/p/128145128
- https://github.com/senghoo/golang-design-pattern