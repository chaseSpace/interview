# Redis 相关

本文内容摘自网络。

## 为什么 Redis 使用单线程

- 简单高效：单线程模型使 Redis 的开发和维护更加简单，不需要处理多线程带来的加锁、线程同步等复杂情况。
- 瓶颈不在 CPU：Redis 作为内存数据库，性能瓶颈主要在内存和网络带宽而非 CPU。
- 数据结构简单：Redis 的数据结构被专门设计得很简单高效，绝大部分操作的时间复杂度都是 O(1)，因此单线程已经足以应对大部分读写场景。
- I/O 多路复用：利用了操作系统提供的多路 I/O 复用 epoll 模型，可以高效地监听和处理多个客户端连接。

## 单线程的瓶颈

- 只能用一个 cpu 核(忽略后台线程)
- 如果 value 比较大，redis 的 QPS 会下降得很厉害，有时一个大 key 就可以拖垮
- QPS 难以更上一层楼

## 为什么 Redis 后来引入多线程

### Redis 4.x 的多线程

Redis 在 4.x 版本引入了多线程，用来**异步**执行`UNLINK`、`FLUSHALL ASYNC`、`FLUSHDB ASYNC`命令。
比如对于键的删除，我们一般不需要同步等待完成，而且删除大键是一个耗时操作。所以引入多线程是方便执行那些不需要同步返回的命令。

> [!NOTE]
> `UNLINK`是 Redis 4.0 新增的命令，用于异步删除一个（较大的）键，返回值是实际解除链接的键的数量。
> `DEL`命令仍然是同步删除一个键。

### Redis 6.x 的多线程 I/O

Redis 官方在 2020 年 5 月正式推出 6.0 版本，此版本正式引入了多线程 I/O。

首先要解释 **Redis 的单线程**：Redis 在处理客户端的请求时，包括获取 (socket 读)、解析、执行、内容返回 (socket 写)
等都由一个顺序串行的主线程处理。

随着硬件性能提升，Redis 的单线程性能瓶颈可能出现在网络 IO 的读写，也就是：单个线程处理网络读写的速度跟不上底层网络硬件的速度。
读写网络的 read/write 系统调用占用了 Redis 执行期间大部分 CPU 时间，瓶颈主要在于网络的 IO 消耗。
此时的优化方向：

- 提高网络 IO 性能，典型的实现比如使用 DPDK 来替代内核网络栈的方式。
- 使用多线程充分利用多核，提高网络请求读写的并行度，典型的实现比如 Memcached。

Redis 采用了第二种方式，即 Redis 采用多个 IO 线程来处理网络请求，提高网络请求处理的并行度。
**需要注意的是**，Redis 多 IO 线程模型只用来处理网络读写请求，对于 Redis 的读写命令，依然是单线程处理。

**开启多线程**

Redis 6.0 的多线程默认是禁用的，只使用主线程。如需开启需要修改 redis.conf 配置文件：

```shell
io-threads-do-reads yes
io-threads 4 # 建议为CPU核数-1
```

## Redis的多路复用与 HTTP/2 有何不同

**应用层别不同**

HTTP/2 的多路复用发生在应用层，即在一个 TCP 连接上复用多条流。而 Redis 的多路复用发生在更底层的网络 IO 层，即在一个线程中同时处理多个客户端
socket 连接的 IO 操作。

**目的不同**

HTTP/2 多路复用的主要目的是减少 TCP 连接数，提高带宽利用率。Redis 的多路复用主要目的是保持单线程以及不必要的上下文切换开销。

## Redis的事务实现

Redis 通过 MULTI、DISCARD、EXEC 和 WATCH 四个命令来实现事务功能，事务提供了一种"将多个命令
打包，然后一次性、按顺序地执行"的机制，并且事务在执行期间不被主动中断，一个事务从开始到执行
会经历以下三个阶段：

- WATCH：在事务开始前，用于监视一个或多个键，如果键的值发生了变化，则 EXEC 无法执行，事务中断（在 MULTI 前执行）
    - 事务中断后，WATCH 命令自动取消
    - 单个会话有效
- UNWATCH：取消 WATCH 对所有 key 的监视（在 MULTI 前执行）
- MULTI：标志着事务开始
- 输入其他命令：命令在服务器入列，命令语法错误会导致 EXEC 无法执行，即事务中断（所有命令都不执行）
- EXEC：服务器以先进先出的顺序执行命令，如果命令执行失败，则继续执行下一条命令，也不会回滚已执行的命令。
- DISCARD：取消一个事务（在 EXEC 前执行）

Redis 事务提供一致性和隔离性，但不提供原子性和持久性。

- **一致性**：指不会出现执行一半命令的情况。
- **隔离性**：指事务之间互不干扰，同时也不会在事务内插入其他命令。
- **原子性（X）**：指事务内的命令全部执行或都不执行，无法做到因为一条命令的运行时错误导致其他命令中断。
- **持久性（X）**：因为 Redis 的持久化都是异步的，做不到实时落盘（为了保证性能）。

## 内存淘汰机制

当 Redis 内存不够用时，它根据设置的淘汰策略来删除部分键。支持以下策略：

- no eviction：当内存使用超过配置时就会返回错误，不会驱逐任何键
- allkeys-lru：加入键的时候，如果过限，首先通过 LRU 算法驱逐最久没有使用的键
- voliatile-lru：加入键的时候如果过限，首先从设置了过期时间的键集合中驱逐最久没有使用的键
- allkey-random：加入键的时候如果过限，从所有 key 中随机删除
- voliatile-random：加入键的时候如果过限，从设置了过期时间的键集合中随机删除
- voliatile-ttl：从配置了过期时间的键中驱逐马上就要过期的键
- volatile-lfu：从所有配置了过期时间的键中驱逐使用频率最少的键
- allkeys-lfu：从所有键中驱逐使用频率最少的键

## 什么是缓存血崩

缓存在同一时间大面积的失效，后面的请求都直接落到了数据库上，造成数据库短时间内承受大量的请
求。

**解决办法**

根据缓存血崩的原因执行不同的方案：

- Redis 宕机
    - 集群化或使用哨兵模式部署 Redis。
    - 开启持久化，保证重启后快速恢复缓存数据。
- 大量缓存同时失效
    - 在批量往 redis 存数据的时候，把每个 Key 的失效时间都加个随机值。
    - 或者设置热点数据永远不过期，有更新操作就更新缓存就可以了。
    - 在代码中实现本地缓存，避免请求全部落到数据库。
    - 接口限流。

## 什么是缓存穿透

请求的数据根本不存在，所以缓存 miss，请求一直落到数据库。此时如果请求量较大就会击垮数据库。

**解决办法**

- 添加参数校验。
- 缓存空值 key。

## 什么是缓存击穿

大量的请求同时查询一个 热 key 时，假设此时，这个 key 正好失效了，就会导致大量的请求都打到数据库上面去，这种现象我们称为击穿。
缓存击穿带来的问题就是会造成某一时刻数据库请求量过大，压力剧增。

**解决办法**

- 热点数据永不过期，由定时任务定期去刷新缓存。
- 互斥锁。在缓存 miss 后，从数据库加载缓存前，对操作加一个互斥锁。

## 什么是布隆过滤器

它由一个很长的二进制向量和一系列随机映射函数组成。布隆过滤器可以用于检索出一个元素是否在一个集合中，他的优点是空间效率和查询时间远远超过一般的算法。

**原理**

当一个元素被加入集合时，通过 K 个散列函数将这个元素映射成一个位数组中的
K 个点（offset），把它们置为 1。检索时，我们只要看看这些点是不是都是 1 就（大约）知道集合中有
没有它了：如果这些点有任何一个 0，则被检元素一定不在；如果都是 1，则被检元素很可能在。这就
是布隆过滤器的基本思想。

**优点**

- 空间占用极小，因为本身不存储数据而是用比特位表示数据是否存在，某种程度具有保密的效果。
- 插入与查询操作的时间复杂度均为 O(k)，常数级别，k 表示散列函数执行次数。
- 散列函数之间可以相互独立，可以在硬件指令层加速计算。

**缺点**

- 误差（假阳性率）
- 无法删除

**具体使用**

从 Redis 4.0 开始,布隆过滤器作为一个模块被集成到 Redis 中。我们需要先下载并加载布隆模块。
布隆命令使用：

```shell
# 创建布隆过滤器   bloomFilter是键名   0.03 是允许的最大错误率   2000000是预期存储的元素个数
BF.RESERVE bloomFilter 0.03 2000000

# 添加元素
BF.ADD bloomFilter foo

# 添加多个元素
BF.MADD bloomFilter e1 e2

# 判断存在性
BF.EXISTS bloomFilter foo

# 判断多个元素的存在性
BF.MEXISTS {key} {item} {item} ...

# 查看布隆键信息，包含预设容量、实际占用、已插入元素数量等
BF.INFO {key}
```

若是 redis 3.x 版本，只能使用 redis 的 bitmap 来实现，比较麻烦。

## Redis用途汇总

- 缓存：加快数据访问速度。
- 限流：用做限流算法后端。（包括固定窗口、滑动窗口、漏桶算法、令牌桶）
- 消息队列：使用List和Stream实现简易队列。（不支持事务，仅适合用于存储非关键业务数据）
- 延迟队列：使用ZSet+List实现延迟队列。
- 分布式锁：使用`SETNX`命令实现。
- 分布式Session：使用String存储Session。
- 排行榜：使用ZSet实现。
- 附近的人：使用GeoHash+ZSet实现。
- 共同好友：使用Set结构的`SINTER`命令查询共同好友。
- 计数器：使用`INCR`命令实现。（例如统计同一IP一小时内发送短信次数、同一IP每秒请求数）

累计至少有10种用途。

### 缓存

Redis 实现缓存功能的基本原理是将常用的数据存储在内存中，以加快数据访问速度，并且可以通过设置过期时间来自动淘汰过期的缓存数据。
适合缓存的数据是那些更新频率较低、访问频率较高的数据，例如商品信息、用户信息等。

### 限流

限流是指通过对**一个时间窗口内的请求量**进行限制来保障系统的正常运行。限流有多种算法，分别用于不同的场景。

#### 固定窗口

又叫计数器算法，是一种简单方便的限流算法。主要通过一个支持原子操作的计数器来累计 1 秒内的请求次数，当 1
秒内计数达到限流阈值时触发拒绝策略。每过 1 秒，计数器重置为 0 开始重新计数。

**实现**  
在 Redis 中实现固定窗口限流可以使用计数器和过期时间结合的方式来实现。具体步骤如下：

- 设置计数器键：为每个需要进行限流的接口或操作设置一个对应的计数器键。
- 每次请求计数：每次有请求到达时，将计数器键的计数器值加一。
- 限流判断：判断计数器键的计数器值是否超过设定的阈值，如果超过，则拒绝该请求；否则允许该请求。
- 定时清零：Redis的TTL功能会自动删除计数器键（等同于清零），以实现固定时间窗口的限流。

**缺点**  
主要是临界问题（突刺现象）。在窗口边界处，可能突然到达大量请求，但由于横跨两个窗口，导致被算法判定为合理。

#### 滑动窗口

滑动窗口算法是对固定窗口算法的一种改进。它将时间窗口分为多个子窗口，每个子窗口的大小相同，并且每个子窗口都对应一个计数器。
并且子窗口的间隔越小，滑动窗口的滚动就越平滑，限流的统计就会越精确。

**原理**

- 将固定时间窗口划分成多个小窗口
  - 滑动窗口算法在固定窗口的基础上,将一个固定时间窗口(如1分钟)划分成多个小窗口(如6个,每个10秒)。
- 每个小窗口维护独立的计数器
  - 每个小窗口都有自己独立的请求计数器,记录该小窗口内的请求数量。
- 窗口向前滑动
  - 当请求时间超过当前小窗口的最大时间时,整个时间窗口向前滑动一个小窗口。
  - 滑动时会丢弃第一个小窗口的计数,并在最后添加一个新的小窗口。
- 限流判断
  - 在整个时间窗口内,所有小窗口的请求计数之和不能超过设定的阈值,否则触发限流。

实现步骤略微复杂，此处不再描述。

#### 漏桶算法

漏桶算法（Leaky Bucket Algorithm）是一种常用的限流算法，它的原理类似于水桶中的漏洞。在漏桶算法中，请求会以恒定的速率被处理，
多余的请求将会被丢弃或者排队等待处理。这种算法**可以平滑地处理突发流量**，并且能够保证请求的处理速率不会超过事先设定的阈值。

**原理**

- 漏桶存储结构
  - 漏桶算法使用一个固定容量的漏桶存储请求，该漏桶以固定的速率漏水（放行请求），当有新请求到达时，都会被放入漏桶中等待放行。
- 请求处理
  - 每次有请求到达时，将请求放入漏桶中。如果漏桶已满，则拒绝该请求；否则允许该请求被处理。
- 漏桶处理
  - 漏桶以固定的速率进行漏水，当漏桶中的水满了时，多余的水将会被丢弃，即超出容量的请求将会被拒绝。
- 请求速率控制
  - 漏桶算法通过控制漏水速率来控制请求的处理速率，从而实现限流。

多数编程语言都提供了漏桶算法的实现，例如Go中的`go.uber.org/ratelimit`包。

#### 令牌桶

令牌桶算法（Token Bucket Algorithm）是一种常用的限流算法，它基于令牌桶数据结构来实现。该算法允许请求以一定的速率被处理，
超出速率的请求将被暂时存储或者直接拒绝。

**原理**

- 令牌桶存储结构
  - 令牌桶算法使用一个固定容量的令牌桶来存储令牌，令牌以固定的速率被添加到桶中。每个令牌代表一个可以被处理的请求。
- 令牌产生
  - 令牌桶以固定的速率生成令牌，并将令牌放入桶中。（生成令牌的速率决定了请求处理的速率）
- 请求处理（消耗令牌）
  - 每次有请求到达时，需要消耗令牌桶中的一个令牌才能处理该请求，若桶中令牌不足（说明流量过大），则请求将被延迟或拒绝。
- 请求速率控制
  - 通过调整令牌生成的速率来控制请求的处理速率。
- 允许突发流量
  - 算法允许一定程度的突发流量，因为桶中可以积累一定数量的令牌，从而在某个时间点允许大量数据的发送。

**与漏桶算法对比**

- 速率限制：令牌桶算法允许一定程度的突发传输，而漏桶算法则不允许突发，它强制数据以固定速率传输。
- 应对突发流量：令牌桶算法可以通过桶中积累的令牌应对瞬时的高流量，而漏桶算法则通过丢弃超出速率限制的数据包来避免拥塞。
- 应用场景：令牌桶算法适合需要一定速率限制但又希望允许短时间内的高流量传输的场景，如HTTP服务限流。漏桶算法适合需要严格控制流量速率，平滑流量的场景，
  如网络流量整形。

**优缺点**

- 令牌桶算法的优点在于它提供了更高的灵活性，允许一定程度的突发流量，但可能需要更复杂的实现逻辑。
- 漏桶算法的优点在于它简单且能够有效控制流量速率，但可能不够灵活，无法充分利用网络资源。

### 消息队列

消息队列是一种应用程序间异步通信的机制,它提供了缓存、解耦、削峰填谷和异步通信等功能,是构建分布式系统的重要组件之一。

消息队列选型一般使用RabbitMQ、Kafka、RocketMQ等，但这些服务相对Redis比较重（需要花钱和维护），一般用于关键业务数据，比如订单等。
而对于一些简单的、没有大量消息堆积的非关键业务场景，可以使用Redis实现MQ。

Redis中可以使用List、Stream和Pub/Sub来实现简单的消息队列功能。

#### List实现MQ

Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部(左边)或者尾部(右边)。
通过使用以下命令，可以实现一个简单的消息队列功能：

- LPUSH、RPOP 左进右出
- RPUSH、LPOP 右进左出

使用RPOP、LPOP命令消费数据时有个问题就是需要消费者轮询Redis，所以可以使用 BRPOP、BLPOP 避免这个问题。

**实现ACK机制**

ACK机制用来解决因为网络异常或消费者自身问题导致的消费失败情况。Redis中可以使用双队列形式来实现ACK机制，步骤如下：

- 准备两个队列，其中存储数据的队列为 `queue1`，另一个队列命名为`queue1_bak`；
- 消费者使用 RPOPLPUSH 或 BRPOPLPUSH 命令消费数据（数据在弹出的同时将备份到另一个 bak 队列）；
- 消费者消费数据成功后，使用 LREM 命令销毁 bak 队列的数据；
- 启动定时任务，使用 LRANGE 命令读取队列数据，解析每条数据（需要包含产生时间戳），将超时消息（认为消费失败）重新入队 `queue1`；
  - 超时定义：因为使用Redis的队列的场景一般不存在大量消息堆积，所以我们可以估算一个消息产生到消费的时间差，比如2分钟，可作为超时时间。
  - 因为这里的超时定义并不严谨，所以建议消息中包含唯一id实现幂等消费，否则可能会重复消费。

#### Stream实现MQ

Stream 是 Redis 5.0 引入的一种专门为消息队列设计的数据类型，Stream 是一个包含 0 个或者多个元素的有序队列，这些元素根据 ID
的大小进行有序排列。它实现了大部分消息队列的功能：

- 消息 ID 序列化生成；
- 消息遍历；
- 消息的阻塞和非阻塞读；
- Consumer Groups（消费组）；
  - 消费组的目的是通过多个消费者同时消费一个队列，实现负载均衡和容错。
  - 通过 XGROUP/XREADGROUP/XACK 实现消费者组功能；
- ACK 确认机制；
- 支持多播；
- 提供了很多消息队列操作命令；
- 提供了消息的持久化和主备复制功能*，可以让任何客户端访问任何时刻的数据，并且能记住每一个客户端的访问位置，还能保证消息不丢失；

常用命令：

```shell
# 插入数据(队列中每个元素由键值对的形式组成，不同元素可以包含不同数量的键值对)
# -- * 表示让 Redis 为插入的消息自动生成唯一ID，当然也可以自己定义。
# -- 消息 ID 由两部分组成：毫秒时间戳+序号。序号区分同一毫秒内的多条消息，从0开始。
> XADD stream_key * field1 value1 field2 value2 ...
"1645936602161-0"

# 读取数据
# -- COUNT 为元素个数；BLOCK 为阻塞读取，0表示永久阻塞，大于0表示阻塞时间（毫秒）
# -- 0-0 在读取消息的时候可以指定 ID，并从这个 ID 的下一条消息开始读取，0-0 则表示从第一个元素开始读取。
# -- 若要进行顺序消费，每次读取后要记住返回的消息ID，用做下次 XREAD 的消费ID参数。
# -- 注意，XREAD 只是读取队列消息，并不会从队列中删除元素。
> XREAD COUNT 1 BLOCK 0 STREAMS stream_key 0-0
1) 1) "stream_key"
   2) 1) 1) "1645936602161-0"
         2) 1) "field1"
            2) "value1"
            3) "field2"
            4) "value2"
            
# 新建消费组
# -- 其中cg1 为组名，0-0为起始消息ID，MKSTREAM 参数表示如果该消费组所属的流不存在时自动创建流。
> XGROUP CREATE stream_key cg1 0-0 MKSTREAM


# 使用一个新的stream测试消费组
# 在读取消息前插入一些数据
XADD bossStream * name zhangsan age 26
XADD bossStream * name lisi age 2
XADD bossStream * name bigold age 40

# 通过消费组读取消息（此命令与XREAD大同小异）
# -- 最后的参数">"，表示从尚未被消费的消息开始读取；
# -- 此时同组的其他消费者将不能读取到此消息，而是读取下一条"lisi"
# -- 注意：此时读取到的消息还未确认，所以还存在于stream。
> XREADGROUP GROUP cg1 consumer1 COUNT 1 BLOCK 0 STREAMS bossStream >
1) 1) "stream_key"
   2) 1) 1) "1645957821396-0"
         2) 1) "name"
            2) "zhangsan"
            3) "age"
            4) "26"

# 同组的其他消费者读取 "lisi"
> XREADGROUP GROUP 青龙门 consumer2 COUNT 1 BLOCK 0 STREAMS bossStream >
1) 1) "bossStream"
   2) 1) 1) "1645957838700-0"
         2) 1) "name"
            2) "lisi"
            3) "age"
            4) "2"

# 查看已读未确认消息
# -- Stream 内部有一个队列（pending List）保存每个消费者读取但是还没有执行 ACK 的消息。
# -- 返回结果中的 1) 表示未确认消息的个数。2) ~ 3) 表示所有消费者读取的消息最小和最大ID；
> XPENDING bossStream cg1
1) (integer) 2
2) "1645957821396-0"
3) "1645957838700-0"
4) 1) 1) "consumer1"
      2) "1"
   2) 1) "consumer2"
      2) "1"

# 查看 cg1.consumer1 读取的消息
# 用法：XPENDING key group [start end count] [consumer]
> XPENDING bossStream cg1 - + 10 consumer1
1) 1) "1645957821396-0"
   2) "consumer1"
   3) (integer) 3758384 # 自上次消息传递给消费者以来经过的毫秒数
   4) (integer) 1 # 该消息被传递的次数
   
# 确认消息
# -- 用法：XACK key group-key ID [ID ...]
# -- 消费成功后，ACK 通知 Streams，这条消息就会被删除。
> XACK bossStream cg1 1645957821396-0 1645957838700-0
(integer) 2
```

其他命令：

```shell
XTRIM key MAXLEN [~] count  # 对流进行修剪，限制长度
XDEL key ID [ID ...]  # 删除流中的消息
XLEN key # 获取流包含的元素数量，即消息长度
XRANGE key start end [COUNT count] # 获取消息列表，会过滤已经删除的消息

# 删除组
XGROUP DESTROY mystream some-consumer-group
# 删除组内消费者
XGROUP DELCONSUMER mystream consumer-group-name myconsumer123

# 获取流的各项信息
XINFO STREAM mystream # 如消息数量、消费组数量、第一个和最后一个消息ID
XINFO GROUPS mystream
XINFO CONSUMERS mystream mygroup  # 含该消费者当前未确认的消息数量等信息
```

#### 发布订阅实现MQ

> 严格来说 "发布/订阅" 只是一个广播机制，而不是真正的消息队列，因为不支持消息累积。

Redis 通过 PUBLISH 、SUBSCRIBE 等命令实现了订阅与发布模式，这个功能提供两种信息机制，
分别是订阅/发布到频道和订阅/发布到模式（一个类似正则表达式的 Key）。

"发布/订阅"模式包含两种角色，分别是发布者和订阅者。订阅者可以订阅一个或者多个频道(channel)，
而发布者可以向指定的频道(channel)发送消息，所有订阅此频道的订阅者都会收到此消息。频道我们可以先理解为是个 Redis 的 key
值，而模式，可以理解为是一个类似正则匹配的 Key，只是个可以匹配给定模式的频道。这样就不需要显式的去订阅多个名称了，可以通过模式订阅这种方式，一次性关注多个频道。

**缺点**

由于Redis不会存储消息，所以只有在线的订阅者可以实时接收消息（并且没有ACK机制），离线订阅者会永远丢失消息。

**常用命令**

```shell
# 订阅N个频道
SUBSCRIBE channel [channel ...]
# 取消订阅
UNSUBSCRIBE [channel [channel ...]]

# 发布消息到指定频道
PUBLISH channel message

---

# （取消）订阅模式: 订阅符合模式的所有频道
# -- 模式支持 glob 风格的正则表达式，例如
#   - h?llo subscribes to hello, hallo and hxllo
#   - h*llo subscribes to hllo and heeeello
#   - h[ae]llo subscribes to hello and hallo, but not hillo
PSUBSCRIBE pattern [pattern ...]
PUNSUBSCRIBE [pattern [pattern ...]]
```