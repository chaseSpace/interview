# Redis 相关

本文内容摘自网络。

## 为什么 Redis 使用单线程

- 简单高效：单线程模型使 Redis 的开发和维护更加简单，不需要处理多线程带来的加锁、线程同步等复杂情况。
- 瓶颈不在 CPU：Redis 作为内存数据库，性能瓶颈主要在内存和网络带宽而非 CPU。
- 数据结构简单：Redis 的数据结构被专门设计得很简单高效，绝大部分操作的时间复杂度都是 O(1)，因此单线程已经足以应对大部分读写场景。
- I/O 多路复用：利用了操作系统提供的多路 I/O 复用 epoll 模型，可以高效地监听和处理多个客户端连接。

## 单线程的瓶颈

- 只能用一个 cpu 核(忽略后台线程)
- 如果 value 比较大，redis 的 QPS 会下降得很厉害，有时一个大 key 就可以拖垮
- QPS 难以更上一层楼

## 为什么 Redis 后来引入多线程

### Redis 4.x 的多线程

Redis 在 4.x 版本引入了多线程，用来**异步**执行`UNLINK`、`FLUSHALL ASYNC`、`FLUSHDB ASYNC`命令。
比如对于键的删除，我们一般不需要同步等待完成，而且删除大键是一个耗时操作。所以引入多线程是方便执行那些不需要同步返回的命令。

> [!NOTE]
> `UNLINK`是 Redis 4.0 新增的命令，用于异步删除一个（较大的）键，返回值是实际解除链接的键的数量。
> `DEL`命令仍然是同步删除一个键。

### Redis 6.x 的多线程 I/O

Redis 官方在 2020 年 5 月正式推出 6.0 版本，此版本正式引入了多线程 I/O。

首先要解释 **Redis 的单线程**：Redis 在处理客户端的请求时，包括获取 (socket 读)、解析、执行、内容返回 (socket 写)
等都由一个顺序串行的主线程处理。

随着硬件性能提升，Redis 的单线程性能瓶颈可能出现在网络 IO 的读写，也就是：单个线程处理网络读写的速度跟不上底层网络硬件的速度。
读写网络的 read/write 系统调用占用了 Redis 执行期间大部分 CPU 时间，瓶颈主要在于网络的 IO 消耗。
此时的优化方向：

- 提高网络 IO 性能，典型的实现比如使用 DPDK 来替代内核网络栈的方式。
- 使用多线程充分利用多核，提高网络请求读写的并行度，典型的实现比如 Memcached。

Redis 采用了第二种方式，即 Redis 采用多个 IO 线程来处理网络请求，提高网络请求处理的并行度。
**需要注意的是**，Redis 多 IO 线程模型只用来处理网络读写请求，对于 Redis 的读写命令，依然是单线程处理。

**开启多线程**

Redis 6.0 的多线程默认是禁用的，只使用主线程。如需开启需要修改 redis.conf 配置文件：

```shell
io-threads-do-reads yes
io-threads 4 # 建议为CPU核数-1
```

## Redis 的多路复用与 HTTP/2 有何不同

**应用层别不同**

HTTP/2 的多路复用发生在应用层，即在一个 TCP 连接上复用多条流。而 Redis 的多路复用发生在更底层的网络 IO 层，即在一个线程中同时处理多个客户端
socket 连接的 IO 操作。

**目的不同**

HTTP/2 多路复用的主要目的是减少 TCP 连接数，提高带宽利用率。Redis 的多路复用主要目的是保持单线程以及不必要的上下文切换开销。

## Redis 的事务实现

Redis 通过 MULTI、DISCARD、EXEC 和 WATCH 四个命令来实现事务功能，事务提供了一种"将多个命令
打包，然后一次性、按顺序地执行"的机制，并且事务在执行期间不被主动中断，一个事务从开始到执行
会经历以下三个阶段：

- WATCH：在事务开始前，用于监视一个或多个键，如果键的值发生了变化，则 EXEC 无法执行，事务中断（在 MULTI 前执行）
    - 事务中断后，WATCH 命令自动取消
    - 单个会话有效
- UNWATCH：取消 WATCH 对所有 key 的监视（在 MULTI 前执行）
- MULTI：标志着事务开始
- 输入其他命令：命令在服务器入列，命令语法错误会导致 EXEC 无法执行，即事务中断（所有命令都不执行）
- EXEC：服务器以先进先出的顺序执行命令，如果命令执行失败，则继续执行下一条命令，也不会回滚已执行的命令。
- DISCARD：取消一个事务（在 EXEC 前执行）

Redis 事务提供一致性和隔离性，但不提供原子性和持久性。

- **一致性**：指不会出现执行一半命令的情况。
- **隔离性**：指事务之间互不干扰，同时也不会在事务内插入其他命令。
- **原子性（X）**：指事务内的命令全部执行或都不执行，无法做到因为一条命令的运行时错误导致其他命令中断。
- **持久性（X）**：因为 Redis 的持久化都是异步的，做不到实时落盘（为了保证性能）。

## 内存淘汰机制

当 Redis 内存不够用时，它根据设置的淘汰策略来删除部分键。支持以下策略：

- no eviction：当内存使用超过配置时就会返回错误，不会驱逐任何键
- allkeys-lru：加入键的时候，如果过限，首先通过 LRU 算法驱逐最久没有使用的键
- voliatile-lru：加入键的时候如果过限，首先从设置了过期时间的键集合中驱逐最久没有使用的键
- allkey-random：加入键的时候如果过限，从所有 key 中随机删除
- voliatile-random：加入键的时候如果过限，从设置了过期时间的键集合中随机删除
- voliatile-ttl：从配置了过期时间的键中驱逐马上就要过期的键
- volatile-lfu：从所有配置了过期时间的键中驱逐使用频率最少的键
- allkeys-lfu：从所有键中驱逐使用频率最少的键

## 什么是缓存血崩

缓存在同一时间大面积的失效，后面的请求都直接落到了数据库上，造成数据库短时间内承受大量的请
求。

**解决办法**

根据缓存血崩的原因执行不同的方案：

- Redis 宕机
    - 集群化或使用哨兵模式部署 Redis。
    - 开启持久化，保证重启后快速恢复缓存数据。
- 大量缓存同时失效
    - 在批量往 redis 存数据的时候，把每个 Key 的失效时间都加个随机值。
    - 或者设置热点数据永远不过期，有更新操作就更新缓存就可以了。
    - 在代码中实现本地缓存，避免请求全部落到数据库。
    - 接口限流。

## 什么是缓存穿透

请求的数据根本不存在，所以缓存 miss，请求一直落到数据库。此时如果请求量较大就会击垮数据库。

**解决办法**

- 添加参数校验。
- 缓存空值 key。

## 什么是缓存击穿

大量的请求同时查询一个 热 key 时，假设此时，这个 key 正好失效了，就会导致大量的请求都打到数据库上面去，这种现象我们称为击穿。
缓存击穿带来的问题就是会造成某一时刻数据库请求量过大，压力剧增。

**解决办法**

- 热点数据永不过期，由定时任务定期去刷新缓存。
- 互斥锁。在缓存 miss 后，从数据库加载缓存前，对操作加一个互斥锁。

## 什么是布隆过滤器

它由一个很长的二进制向量和一系列随机映射函数组成。布隆过滤器可以用于检索出一个元素是否在一个集合中，他的优点是空间效率和查询时间远远超过一般的算法。

**原理**

当一个元素被加入集合时，通过 K 个散列函数将这个元素映射成一个位数组中的
K 个点（offset），把它们置为 1。检索时，我们只要看看这些点是不是都是 1 就（大约）知道集合中有
没有它了：如果这些点有任何一个 0，则被检元素一定不在；如果都是 1，则被检元素很可能在。这就
是布隆过滤器的基本思想。

**优点**

- 空间占用极小，因为本身不存储数据而是用比特位表示数据是否存在，某种程度具有保密的效果。
- 插入与查询操作的时间复杂度均为 O(k)，常数级别，k 表示散列函数执行次数。
- 散列函数之间可以相互独立，可以在硬件指令层加速计算。

**缺点**

- 误差（假阳性率）
- 无法删除

**具体使用**

从 Redis 4.0 开始,布隆过滤器作为一个模块被集成到 Redis 中。我们需要先下载并加载布隆模块。
布隆命令使用：

```shell
# 创建布隆过滤器   bloomFilter是键名   0.03 是允许的最大错误率   2000000是预期存储的元素个数
BF.RESERVE bloomFilter 0.03 2000000

# 添加元素
BF.ADD bloomFilter foo

# 添加多个元素
BF.MADD bloomFilter e1 e2

# 判断存在性
BF.EXISTS bloomFilter foo

# 判断多个元素的存在性
BF.MEXISTS {key} {item} {item} ...

# 查看布隆键信息，包含预设容量、实际占用、已插入元素数量等
BF.INFO {key}
```

若是 redis 3.x 版本，只能使用 redis 的 bitmap 来实现，比较麻烦。
