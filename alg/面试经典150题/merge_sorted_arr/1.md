## 合并2个有序数组

给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。

请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。

注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，
其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。

## 示例

示例1
输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
输出：[1,2,2,3,5,6]
解释：需要合并 [1,2,3] 和 [2,5,6] 。
合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。

示例2
输入：nums1 = [1], m = 1, nums2 = [], n = 0
输出：[1]
解释：需要合并 [1] 和 [] 。
合并结果是 [1] 。

示例3
输入：nums1 = [0], m = 0, nums2 = [1], n = 1
输出：[1]
解释：需要合并的数组是 [] 和 [1] 。
合并结果是 [1] 。
注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。

## 进阶

你可以设计实现一个时间复杂度为 O(m + n) 的算法解决此问题吗？

## 解题思路

### 先把题意翻译成“人话”

- 有两个“已经排好序”的列表 A、B。
- A 后面多塞了 n 个 0，当作“空座位”。
- 目标：把 B 的所有元素塞进 A，让座位的最终顺序仍然“从小到大”。
- 要求：不能新开一个列表当“临时仓库”，必须原地改 A。

### 最笨最容易的办法（复杂度最高）

“先扔进去，再排序”。即直接把 B 的全部元素搬到 A 的尾巴，然后整体排序。

**伪代码**

```
for j in 0..n-1:
    A[m+j] = B[j]
sort(A)
```

**复杂度**

- 时间：O((m+n) log(m+n)) —— 排序最耗时
- 空间：O(1)（如果排序用原地算法，如快排）

### 进阶办法（降低复杂度）——临时数组

思路：新建一个临时数组 tmp，长度 m+n。用两根指针分别从左到右扫 A、B，每次把较小的那个放进 tmp，最后再把 tmp 抄回 A。

**复杂度**

- 时间：O(m+n) —— 每个元素只被处理一次
- 空间：O(m+n) —— 临时数组

### 最优办法——从后往前双指针

思路：既然 A 后面有空座位，我们“从后往前”找最大的元素，直接放到 A 的最后一个座位，谁大谁坐，坐完就往前挪。这样不会踩到还没处理的元素。

**关键点**

- 三指针：i = m-1（nums1 有效尾部），j = n-1（nums2 尾部），k = m+n-1（写入位置）。
- 谁大谁填到 k，对应指针前移；nums2 剩余一次性搬。
- 原地完成，时间 O(m+n)，空间 O(1)。

口诀：谁大谁填 k。

**伪代码**

```
i = m - 1     // A 有效区末尾
j = n - 1     // B 末尾
k = m + n - 1 // A 全局末尾
while i >= 0 and j >= 0:
    if A[i] > B[j]:
        A[k--] = A[i--]
    else:
        A[k--] = B[j--]
// 如果 B 剩了（A 剩的不用动，已经在前面）
while j >= 0:
    A[k--] = B[j--]
```